#JDK란 무엇일까?
'개발자들이 Java 프로그램을 만들 수 있도록 다양한 기능을 제공하는 키트.' 컴파일러, JRE, JVM 등의 도구들을 가지고 있다.

일반 사용자들이 자바로 만든 프로그램을 실행만 해보고 싶다면 JRE만 설치해도 되지만,
자바로 무엇인가를 만들어보고 싶다면 JDK를 설치해야 한다.

#JDK 구성
-javac : 자바 컴파일러 (자바 소스파일 => 바이트코드로 변환)
-java : javac가 만든 클래스 파일을 해석 및 실행
-jdb : 자바 디버깅 툴

-------------------------------------------------------------------

#JRE
자바 코드를 실행하기 위한 도구들.
'자바 클래스 라이브러리 / JVM / 자바 클래스 로더'를 가지고 있다.
작성된 자바 코드를 JVM에게 넘겨 실행시켜줌.
즉, 'JRE는 JVM이 원활히 작동할 수 있게 환경을 맞춰주는 역할을 함'.

#JVM
Java가 실제로 동작하는 가상환경
'자바 프로그램이 다양한 OS 혹은 기기에서도 원활히 실행될 수 있도록 해줌.'
또한 메모리를 효율적으로 관리해주며 이를 Garbage Collection이라 칭함.

-------------------------------------------------------------------

자바 개발 키트 (Java Devleopement Kit, JDK)는 자바 애플리케이션을 구축하기 위한 핵심 플랫폼 구성요소이다.
이 중심에는 자바 컴파일러가 있다.

JDK는 자바 가상 머신(Java Virtual Machine, JVM), 그리고 자바 런타임 환경(Java Runtime Enviroment, JRE)
과 함께 자바 프로그래밍에 사용되는 3대 핵심 기술 패키지 가운데 하나이며, 이 3가지 기술이 어떻게 연결되어 있는지,
또한 어떻게 다른지 구별하는 것이 중요하다.

-JVM은 프로그램을 실행하는 자바 플랫폼 구성요소이다.
-JRE는 JVM을 생성하는 디스크 상의 부분이다.
-JDK는 개발자들이 JVM과 JRE에 의해 실행되고 구동될 수 있는 자바 프로그램을 생성할 수 있게 해준다.

JDK는 자바 기반 소프트웨어를 개발하기 위한 도구들로 이루어진 패키지, JRE는 자바 코드를 실행하기 위한 도구들로 구성된 패키지
JRE는 단지 자바 프로그램을 구동하기 위한 독립형 구성요소로써 사용될 수 있지만, 동시에 JDK의 일부이기도 하다. 자바 프로그램을 구동하는ㄱ
자바 프로그램 개발의 일환이기 때문에 JDK는 JRE를 필요로 한다. 다음 그림은 JDK가 자바 애플리케이션 개발 라이프사이클에서 어디에 속하는지 알려준다.

DK에 대한 기술적 정의와 일반적 정의는 다음과 같다.
-기술적 정의 : JDK는 컴파일러와 클래스 라잉브러리를 포함하는, 자바 플렛폼 사양서의 구현이다.
-일반적인 정의 : JDK는 '개발자가 자바 기반 애플리케이션 개발을 위해 다운로드하는 소프트웨어 패키지'아다.

#Source code -> Compiler -> Byte code -> JVM(Interpreter for Mac, Window, Linux)

#JDK 종류
1.Java SE
    Java Standard Edition
    표준 에디션의 자바 플랫폼. '자바 언어의 핵심 기능 제공'
    주요 패키지는 java.lang, java.io, java.util, javax.rmi...

2.Java EE
    Java Enterprise Edition
    JavaSE에 '웹 어플리케이션 서버에서 동작하는 기능을 추가한 플랫폼'
    즉, 서버 측 개발을 하기 위해 필요.
    JSP, Servlet, JDBC 등 기업용 애플리케이션을 개발하는데 필요한 다양한 것들이 포함된 플랫폼.
    이 스펙에 따라 제품을 구현된 것을 'WAS' 라고 한다.

3.Java ME
    Java Micro Edition
    임베디드 기기들에서 구동되기 위한 환경을 제공하는 API를 모아둔 플랫폼.
    제한된 자원을 가진 휴대전화, PDA 등에서 java 프로그래밍 언어를 지원하기 위해 만든 플랫폼 중 하나이다


#JDK와 자바 컴파일러
모든 JDK는 자바 애플리케이션 구동에 이용되는 환경이 JRE뿐만 아니라, 자바 컴파일러도 포함하고 있따.
'javac는 평범한 텍스트인 원시(RAW) .java 파일을 받아서 실행 가능한 .class 파일로 만드는 기능이 있는 소프트웨어이다'.
곧 컴파일러 사용을 볼 수 있을 것이다. 우선, 개발 환경으로 JDK를 다운로드해 설정하는 방법을 알려 줄 것이다.

#JDK 시작하기
개발환경에서 자바를 설정하는 것은 JDK를 다운로드하고, 그것을 클래스경로(classpath)에 추가하는 정도로 매우 쉽다.
사용할 JDK를 다운로드 할 때, 사용할 자바 버전을 선택해야 한다. 자바는 하위 호환성을 유지하고 있으므로, 최신 버전을 다운받으면 된다.

#JVM이란?
1.JVM이란 JAVA Vitual Machine, 자바 가상 머신의 약자를 따서 줄여 부르는 용어이다.
(가상머신이란 프로그램의 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이다.) 'jvm 역할은 자바
애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다'. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을
수행하여 JAVA가 OS에 구애받지 않고 재사용을 가능하게 해준다. 그리고 가장 중요한 메모리관리, garbage collection을 수행한다.
그리고 JVM은 스택기반의 가상머신이다. ARM 아키텍쳐 같은 하드웨어는 레지스터 기반으로 동작하는 데 비해 JVM은 스택기반으로 동작한다.

2.자바 가상 머신이란 자바 바이트 코드를 실행시키기 위한 가상의 기계라고 할 수 있다.
자바로 작성된 모든 프로그램은 자바 가상 머신에서만 실행될 수 있으므로, 자바 프로그래을 실행하기 위해서는 반드시
자바 가상 머신이 설치되어 있어야 합니다.
따라서 오라클은 대부분의 주요 운영체제뿐만 아니라 웹 브라우저, 스마트폰, 가전기기 등에서도 자바 가상 머신을 손쉽게 설치할 수 있도록 지원하고 있습니다.
서로 다른 운영체제라도 자바 가상 머신만 설치되어 있다면, 같은 자바 프로그램이 아무런 추가 조치 없이 동작할 수 있다.
따라서 개발자는 한 번만 프로그램을 작성하면, 모든 운영체제에서 같이 사용할 수 있는 장점이 있다.
단,자바 프로그램과는 달리 자바 가상머신은 운영체제에 종속적이므로, 각 운영체제에 맞는 자바 가상 머신을 설치해야한다.
또한, 자바 프로그램은 일반 프로그램보다 자바 가상 머신이라는 한 단계를 더 거쳐야 하므로, 상대적으로 실행 속도가 느리다라는 단점

#왜 자바 가상머신을 알아야 하는가?
한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서가 그 답이 될지 모르겠다. 메모리 효율성을 위해
메모리 구조를 알아야 하기 때문이다. 동일한 기능의 프로그램이더라도 메모리 관리에 따라 성능이 좌우된다. 메모리
관리가 되지 않은 경우 속도저하 현상이나 튕김 현상 등이 일어날 수 있다.

#자바프로그램 실행과정
1.프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.
    JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2.자바 컴파일러(JAVAC)가 자바 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환시킨다.
3.Class Loader를 통해 class파일들을 JVM으로 로딩한다.
4.로딩된 class파일들은 Exception engine을 통해 해석된다.
5.해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게 된다.
    이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업을 수행한다.

#자바 컴파일러 
자바 컴파일러는 자바를 가지고 작성한 자바 소스 코드를 자바 가상 머신의 이해할 수 있는 자바 바이트 코드로 변환
자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치됨

#자바 바이트 코드
자바 바이트 코드 란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다.
자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있다.
이러한 자바 바이트 코드의 확장자는 .class이다. 자바 바이트 코드는 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서라도 실행이 가능하다.

#간단한 자바 프로그램
자바 프로그램은 한 개 이상의 클래스(class)로 구성됩니다.
이러한 클래스는 한 개 이상의 필드나 메소드로 구성됨

ex)
class Test {
    int field1;
    String field2;

    public void method() {
        System.out.println("자바 프로그래밍");
    }
}

# main() 메소드
자바 프로그램이 실행되면 맨 먼저 main() 메소드를 찾아 그 안의 모든 명령문을 차례대로 실행합니다.
따라서 하나의 자바 프로그램에는 main() 메소드를 가지는 클래스가 반드시 하나는 존재해야 한다.

#명령문(statement) 
자바 프로그램의 동작을 명시하고, 이러한 동작을 컴퓨터에 알려주는 데 사용되는 문장을 명령문(statement)라고 한다.
자바의 모든 명령문은 반드시 세미콜론으로 끝나야 한다.

#메모리의 구조
프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드되어야 한다.
또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요하다.
따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공한다.
프로그램이 운영체제로 부터 할당받는 대표적인 메모리 공간은 다음과 같다.
1.코드 영역 : 실행할 프로그램의 코드
2.데이터 영역 : 전역변수, 정적변수
3.스택 영역 : 지역변수, 매개변수
4.힙 영역 : 사용자의 동적 할당

#코드 영역
메모리의 코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부른다.
CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.

#데이터 영역
메모리의 데이터 영역은 프로그램의 전역(global) 변수와 정적(static) 변수가 저장되는 영역이다.
데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸

#스택 영역
메모리의 스택 영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역이다.
스택영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임이라고 한다. 

#힙 영역
메모리의 힙 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역이다.
힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 헤제됩니다.
힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

#자바 문법 구성요소
-식별자(identifiers) : 사용자가 임의로 Java 프로그램의 구성요소에 붙이는 이름
-키워드(keyword) : 자바 문법상의 영단어, 자바 언어 자체에서 미리 정해놓은 식별자

#자료형
-자료형 : 프로그램에서 사용되는 데이터 유형(data type)
-기본형 : 이미 정해져있는 유형
-참조형 : 기본형 이외의 자료형의 종류 (=객체의 메모리 위치 주소값)
- null : 참조형 자료의 종류, 변수의 메모리 위치 주소값이 안들어가서 대신 넣어 놓는 더미데이터(나중에 넣으려고 비워드는것)
        오라클에서는 데이터를 입력하지 않을 경우 대신 넣어주는 데이터.
-객체의 메모리 위치 주소값 : 접근지정자가 허용한다면 객체의 속성변수와 메소드를 호출할 수 있음.

#변수
-변수 : 데이터가 저장되는 메모리의 기억장소에 붙인 이름. 변수 안의 데이터 값은 수시로 변경(갱신) 가능
-속성 변수(맴버변수) : 기본형 데이터 또는 참조형 데이터가 저장되는 변수. 클래스이 고유 맴버로 클래스 내부에 있음.
-지역 변수 : 메소드 안에서 선언되어 메소드 안에서만 사용되는 변수. 보통 중괄호 안에서 사용
-매개 변수 : 데이터를 전달하면서 메소드를 호출할 때 전달 데이터를 저장할 변수.
            (메소드, 생성자 안에 있는 둥글괄호) 0개 이상 가능
            형식) 메소드명/생성자명/(자료형 매개변수){실행구문}
-변수 선언 : 데이터 저장을 위한 메모리 공간을 확보해달라고 가강머신에게 부탁하는 행위
-할당 : 변수에 데이터를 저장하는 행위
-초기화 : 변수 선언 이후 처음으로 데이터를 저장하는 행위

선언 위치에 따른 변수 명칭
크게 맴버변수와 지역변수로 나뉘며
맴버변수는 클래스변수와 인스턴스변수를 통틀어서 부르는 용어이다.
클래스영역에 선언된 변수를 맴버변수라 하며 그중 앞에 static이 붙은 변수를 클래스 변수라고 한다.

#변수의 선언
자바에서는 변수를 사용하기 전에 반드시 먼저 변수를 선언하고 초기화해야 합니다.
변수를 선언하는 방법에는 다음과 같이 두 가지 방법
1.변수의 선언만 하는 방법
2.변수의 선언과 동시에 초기화하는 방법

#변수의 선언만 하는 방법
이 방법은 먼저 변수를 선언하여 메모리 공간을 할당받고, 나중에 변수를 초기화하는 방법입니다.
하지만 이렇게 선언만 된 변수는 초기화되지 않았으므로, 해당 메모리 공간에는 알 수 없는 쓰레깃값만이 들어가 있습니다.
따라서 선언만 된 변수는 반드시 초기화한 후에 사용해야만 합니다.
자바에서는 프로그램의 안전성을 위해 초기화하지 않은 변수는 사용할 수 없도록 하고 있습니다.
만약 초기화되지 않은 변수를 사용하려고 하면, 자바 컴파일러는 오류를 발생
ex)
int num; // 변수의 선언
System.out.println(num); // 오류발생
num = 20; // 변수의 초기화
System.out.println(num); // 20

위의 예제처럼 정수를 저장하기 위한 메모리 공간을 할당받으면, 반드시 해당 타입의 데이터만을 저장해야 합니다.
만약 다른 타입의 데이터를 저장하려고 하면, 자바 컴파일러는 오류를 발생시킬 것입니다.

#변수의 선언과 동시에 초기화하는 방법
자바에서는 변수의 선언과 동시에 그 값을 초기화할 수 있습니다.
또한, 선언하고자 하는 변수들의 타입이 같다면 이를 동시에 선언할 수도 있습니다.
-문법
1.타입 변수이름[, 변수이름];
2.타입 변수이름 = 초깃값[, 변수이름 = 초깃값];
-예제
int num1, num2; // 같은 타입의 변수를 동시에 선언함.
double num3 = 3.14; // 선언과 동시에 초기화함.
double num4 = 1.23, num5 = 4.56; // 같은 타입의 변수를 동시에 선언하면서 초기화함.

#기본형변수
실제 연산에 사용되는 변수이다.
자바에서는 다음과 같이 8가지 종류의 기본형 변수를 제공하고 있습니다.
-정수형 : byte, short, int, long
-실수형 : float, double
-문자형 : char
-논리형 : boolean

#참조형변수
참조형 변수는 8개의 기본형 변수를 사용하여 사용자가 직접 만들어 사용하는 변수를 의미한다.
기본형 변수는 우리가 잘 알고 있듯이 값을 저장하는 저장공간이다. 그렇다면 참조형 변수는 뭔가 다른가?
크게 보자면 참조형 변수도 일단 변수이기 때문에 값을 저장하는 공간이 맞다. 그러나 저장하는 그 값이 완전히 다른다.
기본형 변수에 저장되는 값은 리터러, 즉 실제값이 저장된다.
다시말해 10, A, true등 있는 그대로의 값을 저장한다는 뜻이다. 하지만 참조형 변수는 다르다.
맨 처음에도 한 번 언급했지만 참조형 변수는 실제 값이 아닌 주소 값을 저장한다.
#주소값
우리가 쓰고 있는 컴퓨터의 메모리에 메모리 주소라는 개념이 들어있다.
즉, 메모리 안에도 주소별로 저장 공간이 배정되어 있다는 뜻이다.
이 주소는 사용자가 확인은 할 수 있지만 직접 정하거나 바꿀 수는 없다.
즉, 참조형 변수는 앞서 설명한 주소 값을 저장하는 변수가 되겠다.

#참조형 변수와 기본형 변수의 차이
자, 차이를 알아보자 그러기 위해 메모리 안을 들여다 보자
메모리의 구조는 그림보다 더 세분화가 되어 있지만 간단하게 3개의 영역으로 나눠보자면
Class/Method/Static영역이라고 되어 있는 부분과 Stack영역, 그리고 Heap영역으로 나눌 수 있다.
우리가 지금 알고 있어아하는 부분은 Stack영역과 Heap영역이다.
앞에서도 말했지만 메모리는 공간마다 주소값을 가지고 있다. 이는 모든 영역에서 동일하다.
이 구조를 보면서 설명을 하자면 기본형 변수는 실제 값이 저장이 되는데 만약 우리가 변수를 선언하면 
Stack영역에 선언한 변수만큼의 공간이 생성이 되고, 그 공간에 안에 값이 들어가게 된다.
int i = 10;
변수선언을 하게되면, Stack영역에 4byte 크기의 이름이 i라는 공간이 생성되고, 그 안에 10이 들어가게 되는 것이다.
그런데 참조형 변수는 얘기가 조금 다르다. 아직 우리가 참조형 변수를 선언하는지에 대해서 자세히 알아보진 않았지만
참조형 변수를 선언해서 예시로 들어보겠다.

String str = new String("java");

참조형 변수의 선언은 이러한 형태로 하게 되는데, 기본형 변수와 비슷한 부분도 있고 다른 부분도 보일 것이다.
예시와 같이 변수를 선언하게 되면 메모리에서 이런 동작을 하게 된다.
기본형 변수처럼 Stack영역에 str이라는 이름을 가진 공간이 생성된다.
여기에서 생성되는 변수의 크기는 4byte의 고정된 크기만 생성이 된다.
(자세한 이유는 나중에 배우겠지만 주소 값만 저장하는 공간이이 때문에 형태에 따른 크기 변화가 필요없기 때문이다.)
그리고 new라는 명령어가 Heap영역에 새로운 저장공간을 생성하게 된다.
공간의 크기는 우리가 넣으려는 값(java)의 크기만큼 생성한다.
그리고 이 공간은 메모리 주소 값을 할당받게 된다.
쉽게 말해서 우리가 어떤 아파트의 몇동 몇호에 이사온거라 생각하면 된다.
이사를 왔으면 어느 아파트 몇동 몇호라는 주소를 갖게 되는거랑 똑같다.
물론 이건 Heap영역에 생성된 공간뿐만 아니라 Stack영역에 생성된 공간도 주소를 할당받게 된다.
기본형 변수도 마찬가지고, 하지만 여기서는 굳이 필요한 내용이 아니기 때문에 생략한 것.

다시 본론으로 돌아와서 이렇게 Heap영역에 공간이 생성되고 주소 값을 할당 받으면
그 주소 값을 Stack영역에 생성된 str이라는 장소에 저장이 되는 것이다.

간단하게 정리하자면 기본형 변수는 Stack영역에서 실제 값을 그대로 저장하지만,
참조형 변수는 먼저 Stack영역에 공간을 생성하고 Heap영역에 새로운 공간을 생성해
실제 값을 저장한 다음에 그 공간의 주소 값을 불러와서 Stack영역에의 공간에 저장한다는 것이다.

즉, 기본형 변수는 실제 값을 저장하고, 참조형 변수는 주소 값을 저장하고 있는 것이다. 

#인스턴스변수
클래스 영역에 선언되고
인스턴스 생성시 만들어진다.
각각의 인스턴스마다 다른 값을 가질 수 있다.
그러므로 인스턴스 생성이 필수이며 각 인스턴스마다 다른 값을 가져야 할 때 사용한다.

#클래스변수
인스턴스변수 앞에 static을 붙이기만 하면 된다.
인스턴스변수가 각각의 인스턴스마다 다른값을 가질 수 있는 거와 달리
값을 공유하는 변수이다.
클래스 로딩시 생성되며, 클래스이름, 변수이름 이렇게 인스턴스 생성 필요없이 바로 쓸 수 있다.

#자역변수
메소드 내에 선언되며 메소드 호출시 생성되고 메소드가 종료되면 사라진다.

#매개변수
흔히 파라미터라고 불린다. 메소드에서 입력값을 받을 때가 있는데, 그때 사용되는 변수를 매개변수라고 한다.
매개변수도 매소드 내에 선언된 것으로 간주되므로 지역변수이다.
인자값은 호출시 메소드입력부의 넣는 값이며 이값은 매개변수에 복사되어 대입된다.

예제)
public class Variable {
    int a;
    static String b;
    void m(int c) {
        int d=c;
    }
    public static void main(String arge[]) {
    int e=0;
    Variable v = new Variable();
    v.m(e);
    }
}
52번줄 a는 기본형변수 이면서 맴버변수의 인스턴스변수
53번줄 b는 참조변수 이면서 맴버변수의 클래스변수
54번줄 c는 기본형변수 이면서 매개변수 이면서 지역변수
55번줄 d는 기본형변수 이면서 지역변수
57번줄 args는 참조변수 이면서 매개변수 이면서 지역변수
58번줄 e는 기본형변수 이면서 지역변수
59번줄 v는 참조변수 이면서 지역변수
60번줄 e는 인자값으로 값0이 매개변수에 복사되어 넣어진다.

#타입 변환
하나의 타입을 다른 타입으로 바꾸는 것을 타입 변환이라고 한다.
자바에서는 boolean형을 제외한 나머지 기본 타입 간의 타입 변환을 자유롭게 수행할 수 있다.
자바에서 다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다.
메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입에서 큰 타입으로의 타입 변환은 생략가능.
하지만 메모리에 할당받능 바이트의 크기가 큰 타입에서 작은 타입으로의 타입 변환은 데이터의 손실이 발생
따라서 상대적으로 바이트의 크기가 작은 타입으로 타입 변환을 할 경우 자바 컴파일러는 오류를 발생시킨다.
#타입 변환의 종류
자바에서 타입 변환은 크게 두가지
1.묵시적 타입 변환(자동 타입 변환) 작은 -> 큰
2.명시적 타입 변환(강제 타입 변환) 큰 -> 작은

#묵시적 타입 변환(자동 타입 변환, implicit conversion)
묵시적 타입 변환이란 대입 연산이나 산술 연산에서 컴파일러가 자동으로 수행해주는 타입 변환을 가리킨다.
자바에서는 데이터의 손실이 발생하지 않거나, 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환을 진행합니다.
ex)
1.double num1 = 10;
2.// int num2 = 3.14;
3.double num3 = 7.0f + 3.14;

sys(num1); = 10.0
sys(num3); = 10.14

위 예제의 1번 라인에서는 double형 변수에 int형 데이터를 대입하므로, int형 데이터가 double형으로 자동 타입 변환됩니다.
하지만 주석 처리된 2번 라인에서는 int형 변수가 표현할 수 있는 범위보다 더 큰 double형 데이터를 대입하므로, 데이터의 손실이 발생합니다.
따라서 이 대입 연산에 대해서는 자바 컴파일러가 오류를 발생시킨다.
3번 라인에서는 float형 데이터와 double형 데이터의 산술 연산을 수행합니다.
이때에도 데이터의 손실이 최소하되도록 float형 데이터가 double형으로 자동 타입 변환됩니다.

이렣게 자바 컴파일러가 자동으로 수행하는 타입 변환은 언제나 데이터의 손실이 최소화되는 방향으로 이루어집니다.
따라서 자바에서는 타입의 표현 범위에 따라 다음과 같은 방향으로 자동 타입 변환이 이루어집니다.
byte형 -> short형 -> int형 -> long형 -> float형 -> double형
-예제
① byte num1 = 100;        // OK
② byte num2 = 200;        // Type mismatch
③ int num3 = 9876543210;  // Out of range
④ long num4 = 9876543210; // Out of range
⑤ float num5 = 3.14;      // Type mismatch

6번 라인에서는 int형 변수가 표현할 수 있는 범위를 벗어난 long형 데이터를 대입하므로, 오류를 발생시킨다.

#명시적 타입 변환(강제 타입 변환, explicit conversion)
명시적 타입 변환이란 사용자가 타입 캐스트 연산자(())를 사용하여 강제적으로 수행하는 타입 변환을 가리킵니다.
자바에서는 다음과 같이 명시적 타입 변환을 수행할 수 있습니다.
-문법
(변환할타입) 변환할데이터
변환시키고자 하는 데이터의 앞에 괄호(())를 넣고, 그 괄호 안에 변환할 타입을 적으면 됩니다.
자바에서는 이 괄호를 타입 캐스트 연산자라고 합니다.
-예제
int num1 = 1, num2 = 4;

① double result1 = num1 / num2;
② double result2 = (double) num1 / num2;
 
System.out.println(result1); = 0.0
System.out.println(result2); = 0.25

위 예제의 1번 라인에서 나눗셈 연산의 결과로는 0이 반환됩니다.
자바에서 산술 연산을 수행하고 얻는 결괏값의 타입은 언제나 피연산자의 타입과 일치해야 합니다.
즉, int형 데이터끼리의 산술 연산에 대한 결곽값은 언제나 int형 데이터의 결과로 나오게 됩니다.
따라서 1나누기 4의 결과로는 0.25가 반환되지만, int형으로 자동 타입 변환되어 0이 반환되게 됩니다.
그리고서 double형 변수에 그 결과가 대입할 때, double형으로 자동 타입 변환되어 0.0이라는 결과가 출력됨

#삼항연산자
삼항연산자는 자바에서 유일하게 피연산자를 세 개나 가지는 조건 연산자입니다.
삼항 연산자의 문법은 다음과 같습니다.
-문법
조건식 ? 반환값1 : 반환값2
물음표(?) 앞의 조건식에 따라 결괏값이 참(true)이면 반환값 1을 반환하고, 결곽값이 거짓(false)이면 반환값2를 반환합니다.

-예제
int num1 = 5, num2 = 7;
int result;

result = (num1 - num2 > 0) ? num1 : num2;
System.out.println("두 정수 중 더 큰 수든 " + result + "입니다.");
실행 결과 -> 두 정수 중 더 큰 수는 7입니다.

#instance of 연산자
instance of 연산자는 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환해 줍니다.
즉, 해당 객체가 어떤 클래스나 인터페이스로부터 생성되었는지를 판별해 주는 역할을 합니다.
-문법
인스턴스이름 instance of 클래스 또는 인터페이스이름
instance of 연산자는 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 true를 반환, 그렇지 않으면 false
-예제
class A {}
class B extends A {}
public static void main (String[] args) {
    A a = new A();
    B b = new B();
    System.out.println(a instanceof A); // true
    System.out.println(b instanceof A); // true
    System.out.println(a instanceof B); // false
    System.out.println(b instanceof B); // true
}

#제어문
자바 프로그램이 원하는 결과를 얻기 위해서는 프로그램의 순차적인 흐름을 제어해야만 할 경우가 생깁니다.
이때 사용하는 명령문을 제어문이라고 하며, 이러한 제어문에는 조건문, 반복문 등이 있습니다.
이러한  제어문에 속하는 명령문들은 중괄호({})로 둘러싸여 있으며, 이러한 중괄호 영역을 블록이라고 합니다.
#조건문
조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.
조건문 중에서도 가장 기본이 되는 명령문으 바로 if문입니다.
자바에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다.
1.if문
2.if / else문
3.if / else if / else문
4.switch문

#if문
if문은 조건식 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않습니다.
-예제
if (ch >= 'a' && ch <= 'z') {
    System.out.println("해당 문자는 영문 소문자 입니다.");
}
-> 해당 문자는 영문 소문자입니다.

#if / else문
if문과 함께 사용하는 else문은 if문과는 반대로 주어진 조건식의 결과가 거짓(false)이면 주어진 명령문을 실행합니다.
-예제
if (ch >= 'a' && ch <= 'Z') {
    System.out.println("해당 문자는 영문 소문자 입니다.");
} else {    
    System.out.println("해당 문자는 영문 소문자가 아닙니다.");
}
-> 해당 문자는 영문 소문자가 아닙니다.

#if / else / else문
-예제
if (ch >= 'a' && ch <= 'z') {
    System.out.println("해당 문자는 영문 소문자입니다.");
} else if (ch >= 'A' && ch <= 'Z') {
    System.out.println("해당 문자는 영문 대문자입니다.");
} else {
    System.out.println("해당 문자는 영문자가 아닙니다.");
}
-> 해당 문자는 영문 대문자입니다.

#반복문
반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문입니다.
프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나

자바에서 사용되는 대표적인 반복문의 형태는 다음과 같습니다.
1. while 문
2. do / while 문
3. for 문

#while문
while문 특정 조건을 만족할 때까지 계속해서 주어진 명령문을 반복 실행합니다.
while문은 우선 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행합니다.
내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단하게 됩니다.
이러헥 조건식의 검사를 통해 반복해서 실행되는 반복문을 루프라고 합니다.
-예제
int i = 0;
while(i < 5) {
    System.out.println("while문이" + (i + 1) + "번째 반복 실행중입니다.");
    i++; // 이 부분을 삭제하면 무한 루프에 빠지게 됨.
}
System.out.println("while문이 종료된 후 변수 i의 값은" + i + "입니다.");
-예제
int i = 0;
while (i<5) {
    System.out.println("while 문이" + (i + 1) + "번째 반복 실행중입니다.");
    i++; // 이 부분을 삭제하면 무한 루프에 빠지게 됨.
}
System.out.println("while문이 종료된 후 변수 i 값은 " + i + "입니다.");
-실행결과
while 문이 1번째 반복 실행중입니다.
while 문이 2번째 반복 실행중입니다.
while 문이 3번째 반복 실행중입니다.
while 문이 4번째 반복 실행중입니다.
while 문이 5번째 반복 실행중입니다.
while 문이 종료된 후 변수 i의 값은 5입니다.

while문 내부에 조건식의 결과를 변경하는 명령문이 존재하지 않을때는 프로그램이 영원히 반복되게 됩니다.
이것을 무한루프에 빠졌다고 하며, 무한루프에 빠진 프로그램은 영원히 종료되지 않습니다.
무한루프는 특별히 의도한 경우가 아니라면 반드시 피해야 하는 상황입니다.
따라서 while문을 작성할 때는 조건식의 결과가 어느 순간 거짓(false)을 갖도록 조건식의 결과르 변경하는 명령문을 반드시 포함시켜야 합니다.
위의 예제에서 조건식의 결과를 변경하는 명령문인 i++를 제거하면, 변수 i의 값은 언제나 1이기 때문에 무한 루프에 빠지게 됩니다.

#for문
for문은 while문과는 달리 자체적으로 초기식, 조건식, 증감식을 모두 포함하고 있는 반복문입니다.
따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있습니다.
-문법
#for(초기식; 조건식; 증감식){}
이때 for문을 구성하는 초기식, 조건식, 증감식은 각각 생략할 수 있습니다.

#while
int i = 0;
while (i<5) {
    System.out.println("while 문이" + (i + 1) + "번째 반복 실행중입니다.");
    i++; // 이 부분을 삭제하면 무한 루프에 빠지게 됨.
}
System.out.println("while문이 종료된 후 변수 i 값은 " + i + "입니다.");
#for
for (i = 0, i < 5, i++){
    System.out.println("for문이" + (i + 1) + "번째 반복 실행중입니다.");
}
System.out.println("for 문이 종료된 후 변수 i 값은" + i + "입니다.");
-실행결과
while 문이 1번째 반복 실행중입니다.
while 문이 2번째 반복 실행중입니다.
while 문이 3번째 반복 실행중입니다.
while 문이 4번째 반복 실행중입니다.
while 문이 5번째 반복 실행중입니다.
while 문이 종료된 후 변수 i의 값은 5입니다.

#기타 제어문
루프의 제어
일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문 실행
하지만 continue 문과 break 문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와 줍니다.
#continue문
continue문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해줍니다.
보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용됩니다.
-예제
for (int i = 1, i <= 100,, i++) {
    if(i % 5 == 0 || i % 7 == 0) {
        System.out.println(i);
    } else {
        continue;
    }
}
실행결과
5, 7, 10, 14, 15......95, 98, 100(5와 7의 배수)

#break문
break문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행합니다.
즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.
-예제
int num = 1, sum = 0;
while(true) { //무한루프
    sum += num;
    if(num == 100) {
        break;
    }
    num++;
}
System.out.println(sum); = 5050

-예제2
for (int i = 2, i < 10, i++){
    for(int j = 2, i < 10, i++){
        if(i == 5) {
            break
        }
        System.out.println(i + "*" + j + "=" + (i*j));
    }
}
실행결과
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
...
4 * 6 = 24
4 * 7 = 28
4 * 8 = 32
4 * 9 = 36

#배열이란?
배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의.
배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(intdex)라고 합니다.
자바에서 인덱스는 언제나 0부터 시작하며, 0을  포함한 양의 정수만을 가질 수 있습니다.
배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조입니다.
배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있다.
하지만 현실적으로 이해하기 쉬운 2차원 배열까지 많이 사용합니다.
#1차원배열
1차원 배열은 가장 기본적인 배열로 다음과 같은 문법에 따라 선언합니다.
1.타입[] 배열의 이름;
2.타입 배열이름[];
타입은 배열 요소로 저장되는 변수의 타입을 명시합니다.
배열 이름은 배열이 선언된 후에 배열에 접근하기 위해 사용됩니다.

위와 같이 선언된 배열은 new 키워드를 사용하여 실제 뱅ㄹ로 생성할 수 있습니다.
-문법
배열이름 = new타입[배열길이];
배열의 길이는 해당 배열이 몇 개의 배열 요소를 가지게 되는지 명시합니다.
또한,, 다음과 같이 배열의 선언과 생성을 동시에 할 수도 있습니다.
-문법2
타입[] 배열이름 = new 타입[배열길이];
자바에서는 이러한 배열도 모두 객체이므로, 각각의 배열은 모두 자신만의 필드와 메소드를 가지고 있습니다.
-예제
int[] grade1 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성
int[] grade2 = new int[3]; // 갈아거 3인 int형 배열의 선언 및 생성

grade1[0] = 85; // 인덱스를 이용한 배열의 초기화
grade1[1] = 65;
grade1[1] = 90;

grade2[0] = 85; // 배열의 길이보다 적은 수의 배열 요소만 초기화

for (int i = 0, i < grade1.length, i++) {
    System.out.print(grade1[i] + ""); // 인덱스를 이용한 배열로의 접근
}
for (int i = 0, i < grade2.length, i++) {
    System.out.print(grade1[i] + ""); // 인덱스를 이용한 배열로의 접근
}
실행결과
grade1 = 85, 65, 90
grade2 = 85, 0, 0
위의 예제처럼 0부터 시작하는 인덱스를 이용하면 각각의 배열 요소에 따로 접근할 수 있습니다.
또한, 배열 grade2 철머 배열의 길이보다 적은 수의 배열 요소만을 초기화 할 경우, 나머지 배열 요소들은 배열의 타입에 맞게 자동으로 초기화

#배열의 초기화
자바에서는 변수와 마찬가지로 배열도 선언과 동시에 초기화할 수 있습니다.
다음고 같이 괄호({})를 사용하여 초깃값을 나열한 것을 초기화 블록이라고 합니다.
자바에서는 이러한 초기화 블록을 이용하여 배열을 선언과 동시에 초기화할 수 있습니다.
-문법
1.타입[] 배열의 이름 = {배열요소1, 배열요소2......};
2.타입[] 배열의 이름 = new 타입[]{배열요소1, 배열요소2, ....};
위의 두 가지 초기화 방법은 완전히 같은 결과를 반환하며, 초기화 블록에 맞춰 자동을 배열의 길이가 설정됩니다.
하지만 다음과 같은 경우에는 첫 번째 방법이 아닌 두 번째 방법만을 사용하여 초기화해야 합니다.
1.배열의 선언과 초기화를 따로 진행해야 할 경우
2.메소드의 인수로 배열을 전달하면서 초기화해야 할 경우
#-예제
int[] grade1 = {70, 90, 80}; // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade2 = new int[]{70, 90, 80}; // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade3;
// grade3 = {70, 90, 80}; // 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함.
int[] grade4;
grade4 = new int[]{70, 90, 80}; // 이미 선언된 배열은 이 방법으로만 초기화할 수 있음.

위의 예제처럼 초기화 블록의 타입과 배열의 타입은 반드시 일치해야 합니다.

다음 예제는 앞선 예제와 같은 배열을 선언과 동시에 초기화 블록으로 초기화하는 예제입니다.
#-예제2
int[] grade = new int[]{85, 65, 90}; // 길이가 3인 int형 배열을 선언과 동시에 초기화
for (int i = 0, i < grade.length, i++){
    System.out.print(grade[i] + ""); // 인덱스를 이용한 배열로의 접근  
}
실행 결과
85 65 90
#-예제3
int[] grade = new int[]{85, 65, 90}; // 길이가 3인 int형 배열을 선언과 동시에 초기화
int sum = 0;

for(int i = 0, i < grade.length, i++) {
    sum += grade[i];
}
System.out.println("모든 과목에서 받은 점수의 합은" + sum + "입니다.");
System.out.println("이 학생의 평균은" + (sum/grade.length) + "입니다.");
실행결과
모든 과목에서 받은 점수의 합은 240입니다.
이 학생의 평균은 80입니다.

#다차운배열
다차원 배열이란 2차원 이상의 배열을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미합니다.
즉, 2차원 배열은 배열 요소로 1차원 배열을 가지는 배열이며,
3차원 배열은 배열 요소로 2차원 배열을 가지는 배열이다.
#2차원 배열
2차원 배열이란 배열의 요소로 1차원 배열을 가지는 배열입니다.
자바에서는 2차원 배열을 나타내는 타입을 따로 제공하지 않습니다.
대신에 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있습니다.
-문법 
1.타입[][] 배열이름;
2.타입 배열이름[][];
타입은 배열 요소로 저장되는 변수의 타입을 설정합니다.
배열 이름은 배열이 선언된 후에 배열에 접근하기 위해 사용됩니다.
#2차원 배열
int[][] arr = new int[2][3];
-예제
int[][] arr = new int[2][3];

int k = 10;
for (int i = 0, i < arr.length, i++) {
    for (int j = 0, j < arr.length, j++) {
        arr[i][j] = k; // 인덱스를 이용한 초기화
        k +=10;
    }
}

for (int i = 0, i < arr.length, i++) {
    for (int j = 0, j < arr[i].length, j++) {
        System.out.println(arr[i][j] + "");
    }
    System.out.println();
}
실행결과
10, 20, 30
40, 50, 60

#구구단
public class test {
    public static void main(String[] args) {

        # 2단부터 시작하고 9단까지 실행하며 반복문이 한번 돌때마다 1씩 증가 시킵니다.
        for (int i=2, i < 10, i++){
            for (in j=1, j < 19, j++){
                System.out.println(i + "x" + j + "=" + i*j);
            }
        }
    }
}

#가변배열
자바에서는 2차원 배열을 생성할 때 열의 길이를 명시하지 않으므로써, 행마다 다른 길이의 배열을 요소로 
저장할 수 있습니다. 이렇게 행마다 다른 길이의 배열을 저장할 수 있는 배열을 가변 배열이라고 합니다.
-예제
int[] arr = new int[3][];
arr[0] = new int[2];
arr[1] = new int[4];
arr[2] = new int[1];

위의 예제처럼 배열을 생성할 때 두번째 첨자를 생략하면 가변 배열을 만들수 있다.
또한, 가변 배열도 초기화 블록을 사용하여 배열을 선언과 동시에 초기화할 수 있습니다.

다음 예제는 앞선 예제와 같은 가변 배열을 선언과 동시에 초기화 블록으로 초기화하는 예제입니다.
-예제
int[][] arr = {
    {10, 20},
    {10, 20, 30, 40},
    {10}
}
실행 결과
10 20 
10 20 30 40 
10

#클래스의 개념
객체 지향 프로그래밍 (OOP, Object-Oriented Programming)
객체 지향 프로그래밍에서는 모든 데이터를 객체로 취급하며, 이러한 객체가 바로 프로그래밍의 중심이 된다.
객체란 간단히 이야기하자면 실생활에서 우리가 인식할 수 있는 사물로 설명할 수 있습니다.
이러한 객체의 상태와 행동을 구체화하는 형태의 프로그래밍이 바로 객체 지향 프로그래밍입니다.
이때 객체를 만들어 내기 위한 설계도와 같은 개념을 클래스라고 합니다.

#클래스(class)
자바에서 클래스란 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용된다.
자바에서는 이러한 설계도인 클래스를 가지고, 여러 객체를 생성하여 사용하게 된다.
클래스는 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성됩니다.
즉, 필드란 클래스에 포함된 변수를 의미합니다.
또한, 메소드란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라고 할 수 있습니다.
-개념
1.객체를 만들어 내기 위한 설계도 혹은 틀
2.연관되어 있는 변수와 메서드의 집합
---------------------------------------------------------------------------------------------
ex)클래스
-차(Car) : 설계도
#필드
-car.modelName = "람보르기니"
-car.modelYear = 2016
-car.color = "주황색"
-car.maxSpeed = 350

#메소드
-car.acecelerate()
-car.brake()

#인스턴스
-내 차 : 설계도에 의해 생상된 차량
-친구 차 : 설계도에 의해 생산된 또 다른 차량
즉, 자동차 인스턴스는 모두 위와 같은 필드와 메소드를 가지게 될 것이다.
하지만 각 인스턴스마다 가지고 있는 프로퍼티의 값은 전부 다를 것입니다.
---------------------------------------------------------------------------------------------
#객체(object)
-개념
1.소프트웨어 세계에 구현할 대상
2.클래스에 선언된 모양 그대로 생성된 실체
-특징
1.클래스의 인스턴스라고 부른다.
2.객체는 모든 인스턴스를 대표한는 포괄적인 의미를 갖는다.
3.oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.

#인스턴스 
자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체를 선언해야 합니다.
이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화라고 합니다.
또한, 이렇게 선언된  해당 클래스 타입의 객체를 인스턴스라고 합니다.
즉,인스턴스란 메모리에 할당된 객체를 의미합니다.
자바에서는 하나의 클래스로부터 여러 개의 인스턴스를 생성할 수 있습니다.
이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.
하지만 해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 됩니다.
-개념
1.설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
2.즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.
-특징
1.인스턴스는 객체에 포함된다고 볼 수 잇다.
2.oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.
3.추상적인 개념과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한다.
-객체는 클래스의 인스턴스이다.
-객체 간의 링크는 클래스 간의 연관 관계의 인스턴스이다.
-실행 프로세스는 프로그램의 인스턴스다.
4.즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
5.인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미한다.

ex)
#클래스#
public class Animal {

}
#객체와 인스턴스
public class Main {
    public static void main(String[] args) {
        Animal cat, dog; // 객체

        #인스턴스화
        cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
        dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    }
}

#클래스 vs 객체
-클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상'을 의미한다.
#객체  vs 인스턴스
-클래스의 타입으로 선언되었을 때 '객체'라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.
-객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
-객체는 '실체', 인스턴스는 '관계'에 초점을 맞춘다.
-객체를 '클래스의 인스턴스'라고도 부른다.
그냥 인스턴스나 객체를 나누긴 어렵다. 거의 같은 의미의 단어
#클래스의 구성 요소 
클래스에는 개게가 가져가야할 구성 멤버가 선언
1.필드
2.생성자.
3.메소드
이 구성 맴버들은 생략되거나 복수 개가 작성될 수 있다.

#필드 : 객체의 데이터가 저장되는 곳
ex) 필드
int fieldName;
-객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
선언된 형태는 변수와 비슷하지만, 필드를 변수라 부르지는 않는다.
'변수는 생성자와 메소드 내에서만 사용되고, 생성자와 메소드가 실행 종료되면 자동 소멸된다'.
'필드는 생성자와 메소드 전체에서 사용되며, 객체가 소멸되지 않는 한 객체와 함께 존재한다'.

ex) 자동차 객체
    고유 데이터 : 제작회사, 모델명, 색깔, 최고 속도
    상태 데이터 : 현재 속도, 엔진 회전 수 
    부품 : 차체, 엔진, 타이어

자동차 클래스를 설계 시 위의 정보들은 필드로 선언되어야 한다.
    자동차 객체                             자동차 클래스
    [고유 데이터]                           public class Car {    
    -제작회사                               String company;
    -모델                                   String model;
    -색깔                                   String color;
    -최고 속도                              int maxSpeed;

    [상태]                                  int speed;
    -현재 속도                              int rpm;
    -엔진 회전 수

    [부품]                                  Body body;
    -차체                                   Engine engine;
    -엔진                                   The tire;
    -타이어                                 }

#필드 선언
필드 선언은 중괄호 블록 어디서든 존재할 수 있따.
생성자 선언과 메소드 선언의 앞, 뒤 어디서든 필드 선언이 가능하다.
하지만, '생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다'.
'생성자와 메소드 중괄호 내부에 선언된 것은 모두 로컬(지역) 변수가 된다'.(필드라고 하지 않음)
필드 선언은 변수의 선언 형태와 비슷하다. (클래스 맴벼 변수로 부르기도 한다.)

#필드 선언 형태
타입 필드 = 초기값;

ex)
String company = "KT";
int maxSpeed = 300;
int currentSpeed;
boolean engineStart;
'만약 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다.'

#필드 사용
필드를 사용하는 것은 필드값을 읽고, 변경하는 작업을 말한다.
클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만,
'클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다'.
필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.
ex)
Person 클래스                           Car 클래스
void method() {                        public class Car {
    # //Car 객체 생성                   # // 필드
    Car myCar = new Car()              int speed;
    # //필드 사용                       
    myCar.speed = 60                   # // 생성자
}                                      Car() {
                                        speed = 0;
                                       }

                                       # // 메소드
                                       void method(...) {
                                           speed = 10;
                                       }
Car 클래스의 speed 필드는 생성자와 메소드에서 변경이 가능하다. (사용 방법이 변수와 동일)
'변수는 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수 있는 반면, (지역 변수) 
필드는 생성자롸 모든 멤소드에서 사용 가능하다. (전역 변수 값은 느낌)'

외부 Person 클래스에서 Car 클래스의 speed 필드값을 사용하려면, Car 객체를 우선 생성해야 한다.
Car myCar = new Car();
myCar 변수가 Car 객체를 참조하게 되면 도트 (.) 연산자로 speed 필드에 접근할 수 있다.
'도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드, 메소드를 사용하고자 할 때 사용한다'.
myCar.speed = 60;
Car 객체의 speed 필드값을 60으로 변경

ex)
# Car 클래스 필드 선언
public class Car {
    #// 필드 선언
    String company = "KIA";
    String model = "Sorento";
    String color = "black";
    int maxSpeed = 200;
    int speed;
}
#외부 클래스에서 Car 필드값 읽고 변경하기
public class CarExample {
    public static void main(String[] args) {
        #// 객체 생성
        Car myCar = new Car();
        
        #// 필드값 일기
        System.out.println("제작회사 : " myCar.company);
        System.out.println("모델명 : " myCar.model);
        System.out.println("색깔 : " myCar.color);
        System.out.println("최고 속도 : " myCar.maxSpeed);
        System.out.println("현재 속도 : " myCar.speed);

        #필드값 변경
        myCar.speed = 60;
        System.out.println("변경된 속도 : " + myCar.speed);
    }
}

#생성자 : 객체 생성 시 초기화(변숙 값에 처음으로 부여하는) 역할 담당
ex) 생성자
ClassName() {}
'new 연산자로 호출되는 특별한 중괄호 {} 블록이다'.
객체 생성 시 초기화를 담당한다. (필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.)
메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고, 반환 타입이 없다.

new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
객체, 초기화 : 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것
생성자를 실행시키지 않고는 클래스로 부터 객체를 만들 수 없다.
'new 연산자에 의해 생성자가 성공적으로 실행된다면, 힙 영역에 객체가 생성되고, 객체의 주소가 반환된다'.
반환된 객체 주소는 클래스 타입 변수에 저장되어, 객체에 접근할 때 이용된다.
만약 생성자가 실행되지 않고 예외(에러)가 발생했다면, 객체는 생성되지 않는다.

#기본 생성자
모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 없다.
클래스 내부에 생성자 선언을 생략했다면, 컴파일러는 아래와 같이 중괄호 {} 블록 내용이 비어있는 기본 생성자를 바이트 코드에 자동 추가 시킨다.
public 클래스() {
    # 기본 생성자
}
클래스가 public class 로 선언되면 기본 생성자에도 public 이 붙지만,
클래스가 public 없이 class 로만 선언되면, 기본 생성자에도 public이 붙지 않는다.
따라서 클래스에 생성자를 선언하지 않아도, 아래와 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시킬 수 있다.
ex)
Car myCar = new Car(); // Car() : 기본 생성자
'클래스에 명시적으로 선언한 생성자가 한 개라도 존재하면, 컴파일러는 기본 생성자를 추가하지 않는다'.
명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다.

#생성자 선언
기본 생성자 대신 생성자를 명시적으로 선언하려면 아래와 같은 형태로 작성한다.
ex)
클래스(매개변선언, ....) { #// 생성자 블록
    #// 객체의 초기화 코드
}
'메소드와 비슷한 모양을 가지지만, 반환 타입이 없고 클래스 이름과 동일하다'.
생성자 블록 내부에는 객체 초기화 코드가 작성되는데, 일반적으로 필드에 초기값을 저장하거나 메소드를 호출하여 객체 사용 전에 필요한 준비를 한다.
매개 변수 선언은 생략할 수 있고, 여러 개를 선언할 수도 있다.
'매개 변수는 new 연산자로 생성자 호출 시 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다'.
ex) #Car 생성자를 호출 시 세 개의 값을 제공할 때
Car myCar = new Car("그랜저", "검정", 300);
두 개의 매개값은 String, 마지막 하나는 int 타입이다.
세 개의 매개 값을 생성자가 받기 위해 아래와 같이 생성자를 선언해야 한다.
ex)
public class Car {
    #// 생성자
    Car(String model, String color, int maxSpeed) {
        ...
    }
}
클래스 생성자가 명시적으로 선언되었을 경우, 반드시 선언된 생성자를 호출해서 객체를 생성해야만 한다.
Car 클래스에 생성자 선언이 있다면, 기본 생성자 ( Car() )를 호출해서 객체를 생성할 수 없고,
Car(String color, int cc)를 호출해서 객체를 생성해야 한다. (매개변수 값이 전달되어야 한다.)

#생성자 선언
public class Car {
    #// todtjdwk
    Car(String color, int cc) {
    }
}

#생성자를 호출해서 객체 생성
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car("검정", 3000);
        #// Car myCar = new Car(); // 기본 생성자는 호출 불가
    }
}

#메소드 : 객체의 동작에 해당하는 실행 블록
ex) 메소드
void methodName() {}
객체의 동작에 해당하는 중괄호 {} 블록이다.
중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다.
메소드를 호출하게 되면 중괄호 블록의 모든 코드들이 일괄적으로 실행된다.
메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
메소드는 객체 간의 데이터 전달 수단으로 사용된다.
외부로부터 매개값을 받을 수 있고, 실행 후 어떤 값을 반환할 수도 있다.

#메소드 반환 타입(return)
메소드가 실행 후 반환하는 값의 타입을 의미한다. (반환값이 있을 수도, 없을 수도 있다.)
메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우, 반환값이 있어야한다.
반환값이 없는 메소드는 반환 타입에 void가 와야 하며,
반환값이 있는 메소드는 반환값의 타입이 와야한다.
ex)
void powerOn() {...} #// 전원을 켜는 메소드는 반환값이 없어도 된다.
double divide(int x, int y) {...} #// 나눗셈 후 결과값을 반환해아 한다.
위의 메소드들은 아래와 같이 호출할 수 있다.
ex)
powerOn(); //반환값, 매개변수 없이 메소드만 호출됨
double result = divide(10, 20); // 매개변수 10을 20으로 나눈 나머지 0.5가 반환되어 저장됨
divide 메소드는 double 타입으로 변환하기 때문에 아래와 같이 int 타입으로 result 변수를 선언하게 되면 컴파일 에러가 발생한다.
ex)
int result = divide(10, 20); // 컴파일 에러
반환값을 반드시 변수에 저장할 필요는 없다.
메소드 실행이 중요한 경우 아래와 같이 변수 선언 없이 메소드를 호출할 수 있다.
divide(10, 20);

#매개 변수의 수를 모를 경우
메소드의 매개 변수는 개수가 이미 정해져 있는 것이 일반적
경우에 따라 메소드를 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다.
ex)여러 개의 수를 모두 합산하는 메소드 일 때, 얼만큼 매개 변수가 입력되는지 알 수 없다.
-해결책 : 매개 변수를 배열 타입으로 선언
ex)
main 메소드의 String[] args 처럼
int sum1(int[] value) {...}
sum1 메소드를 호출할 때 배열을 넘겨줌으로써 배열의 항목 값들을 모두 전달할 수 있다.
#배열의 항목 수는 호출할 때 결정된다.
int[] values = {1, 2, 3};
int result = sum1(values);                      // 이미 생성되어있는 values 배열 전달
int result = sum1(new int[] {1, 2, 3, 4, 5});   // 새로운 배열 생성해서 전달 (불편함)
매개 변수를 배열 타입으로 선언하면, 메소드 호출 전, 배열을 생성해야하는 불편함이 있다.
배열을 생성하지 않고, 값의 리스트만 넘기는 방법도 있다.
아래와 같이 sum2() 메소드의 매개 변수를 "..." 을 사용해서 선언하면,
메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
ex)
int sum2(int ...values) {}
"..."으로 선언된 매개 변수 값은 아래와 같이 메소드 호출 시 리스트로 나열만 해주면 된다.
int result = sum2(1, 2, 3);
int result = sum2(1, 2, 3, 4, 5);
"..."으로 선언된 매개 변수는 배열 타입이므로 아래와 같이 이미 생성된 배열을 직접 매개값으로 전달하여 사용 가능.
ex)
int sum2 (int ...values) {}; // "..."은 배열 생성에 영향을 미치지 않음
int[] values = {1, 2, 3}; // 배열 생성됨
int result = sum2(values); // "..."으로 선언된 매개 형태는 이미 생성된 배열도 받을 수 있다.
int result = sum2(new int[]) {1, 2, 3, 4,5};
즉, 매개 변수의 수를 모를 경우 배열로 매개 변수를 전달하는 2 가지 방법
-미리 배열을 생성하여 전달한다.
-미리 배열을 생성하지 않고, 리스트로 명시한다.
ex) 
매개 변수를 배열로 선언한 sum1, 매개 변수를  "..."으로 선언한 sum2 (동일한 실행 결과)
public class Computer {
    int sum1(int[] values) { #// 매개 변수가 배열로 선언됨
        int sum = 0;
        for(int i = 0, i < values.length, i++) {
            sum += values[i];
        }

        return sum;
    }

    int sum2(int ...values) {
        int sum = 0;
        for(int i = 0, i < values.length, i++) {
            sum += values[i];
        }

        return sum;
    }
}

public class  ComputerExample {
    public static void main(String[] args) {
        Computer myCom = new Computer(); // 객체 생성

        int[] values1 = {1, 2, 3}; 
        int result1 = myCom.sum1(values1); // 미리 생성된 배열 전달
        System.put.println("result1 : "+ result1); // 6

        int result2 = myCom.sum1(new int[] {1, 2, 3, 4, 5}); // 배열 생성후 전달
        System.put.println("result2 : "+ result2); // 15

        int result3 = myCom.sum2(1, 2, 3); // 리스트로 전달
        System.out.println("result3 : "+ result3); //6

        int result4 = myCom.sum2(1, 2, 3, 4, 5);
        System.out.println("result4 : "+ result4); // 15
    }
}
위에서 values1 은 {1, 2, 3} 값을 가진 배열로 나타내었고, result1, 2, 3, 4 변수들을 만들어 결과 값을 나타냄.
myCom 객체에 .sum1 변수를 입력하여 실행하고 실행시킬 값을 {매개변수}에 값을 넣어 실행

#return 문
메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 한다.
return문이 없다면 컴파일 에러가 발생한다. return문이 실행되면 메소드는 이후 즉시 종료된다.
return 문의 리턴값은 리턴 타입이거나, 리턴 타입으로 변환될 수 있어야 한다.
ex) 리턴 타입이 int인 plus() 메소드에서 byte, short, int 타입의 값이 리턴되어도 상관 없다.
byte, short는 int로 자동 타입 변환 되기 떄문!

#return 문 사용시 주의점
-return 문 이후에 실행문이 오면 "Unreachable code" 컴파일 오류 발생
(리턴문 이후 실행문은 결코 실행되지 않음)
int plus(int x, int y) {
    itn result = x + y;
    return result;
    System.out.println(result); // return 문 이후 실행문은 컴파일 에러
}
-하지만 if 문으로 실행문이 분기되는 경우는 컴파일 에러가 발생하지 않는다.
boolean insLeftGas() {
    if(gas == 0) {
        System.out.println("gas가 없습니다.");
        return false;
    }
    System.out.println("gas가 있습니다.");
    return true;
}

#리턴값이 없는 메소드(void)
void 로 선언된 리턴값이 없는 메소드에서도 return 문을 사용할 수 있다.
'return 문을 사용하게 되면 메소드 실행을 강제 종료시킨다'.
ex)
gas 값이 0보다 클 경우, while문 계속 실행, 0일 경우 run() 메소드 즉시 종료
void run() {
    while(true) {
        if(gas > 0) {
            System.out.println("달립니다. (gas 잔량 : "+ gas + ")");
            gas -= 1; // gas = gas-1
        } else {
            System.out.println("멈춥니다. (gas 잔량 : "+ gas + ")");
            return; // run() 메소드 실행 종료 (break; 사용 가능)
        }
    }
}
while 문 1번 돌 떄마다 gas값 1감소, gas 값이 0이 되면 run() 메소드가 종료된다.
위의 예제에서는 return 문 대신 break 문을 사용할 수 있다.
만약 while 문 뒤에 실행문이 추가적으로 더 있을 경우, break 문을 반드시 사용해야 한다.
return 문은 즉시 메소드를 종료시키기 때문이다.
ex)
public class Car {
    #// 필드
    int gas;
    #// 생성자

    #// 메소드
    void setGas(int gas) {
        this.gas = gas; // 리턴값이 없는 메소드로 매개값을 받아서 gas 필드값을 변경
    }

    boolean insLeftGas() {#// 리턴값 boolean인 메소드
        if(gas == 0) {
            System.out.println("gas가 없습니다.");
            return false; // false 리턴
        }
        System.out.println("gas가 있습니다.");
        return true; // true 리턴
    }
    void run() {#// 리턴값 없는 메소드
        while(true) {
            if(gas > 0) {
                System.out.println("달립니다. (gas 잔량 : "+ gas + ")");
                gas -= 1;
            } else {
                System.out.println("멈춥니댜. (gas 잔량 : "+ gas + ")");
                return; // 메소드 실행 종료
            }
        }
    }
}

public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car(); // 객체 생성

        myCar.setGas(5); // Car의 setGas() 메소드 호출

        boolean gasState = myCar.isLeftGas(); // Car의 isLeftGas() 메소드 호출
        if(gasState) {
            System.out.println("출발합니다.");
            myCar.run(); // Car의 run() 메소드 호출
        }

        if(myCar.isLeftGas()) { #// Car의 isLeftGas() 메소드 호출
            System.out.println("gas를 주입할 필요가 없습니다.");
        } else {
            System.out.println("gas를 주입해 주세요.")
        }
    }
}
isLeftGas() 메소드가 boolean 값을 리턴하기 때문에 if 문의 조건식으로 들어갈 수 있다.

#메소드 호출
메소드는 클래스 내부, 외부의 호출에 의해 실행된다.
클래스 내부의 다른 메소드에서 호출할 경우, 단순히 메소드 이름으로 호출하면 되지만
'클래스 외부에서 메소드를 호출할 경우, 우선 클래스로부터 객체를 생성한 뒤,
참조 변수를 이용해서 메소드를 호출해야 한다'.
#메소드 외부 호출
void 외부메소드() { #// 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다
    Car car = new Car();
    Car.run();
    Car.stop();
    Car.sound();
}
#메소드 내부 호출
[메소드 선언]
void run() {...}
void stop() {...}
void sound() {...}

void 내부메소드() { #// 클래스 내부의 다른 메소드에서 호출할 경우, 단순히 메소드 이름으로 호출하면 되지만
    run();
    stop();
    sound();
}
-클래스 내부에서 메소드 호출(객체 내부)
클래스 내부에서 메소드를 호출하려면 아래와 같이 작성한다.
메소드가 매개 변수를 가지고 있을 때, 매개 변수의 타입과 수에 맞게 매개값을 제공한다.
메소드(매개값1, ...);
ex)
객체 내부 method2() 메소드에서 method1() 메소드를 호출하려면 아래와 같다.
public class ClassName {
    void method1 (String p1, int p2) { <-
            |                           |    
    }       | 2.실행                    1.호출(객체 내부)
            V                           |    
    void method2() {                    |
        method1("홍길동", 100)----------- 
    }
}
1.호출에서 method1 ("홍길동", 100)이 호출되면, 매개값인 "홍길동"은 p1 매개변수에 대입되고, p2 매개 변수에 대입된다.
2.실행에서 p1, p2 변수를 이용하게 된다.
메소드가 리턴값이 없거나, 있어도 받고 싶지 않을 경우 위와 같이 모두 호출이 가능하다.
리턴값이 있는 메소드를 호출하고 리턴값을 받고 싶다면, 아래와 같이 변수를 선언하고 리턴값을 저장한다.
ex)
타입 변수 = 메소드(매개값1, ...); // 메소드의 리턴값을 변수에 저장한다.
주의!!!!!!!!!!!
변수 타입은 메소드 리턴 타입과 동일해야 하거나, 자동 타입 변환(큰 자료형으로)이 될 수 있어야 한다.
(int 타입은 double 타입으로 자동 변환 될 수 있기 때문에 int 리턴값은 double 변수에 저장될 수 있다.)
ex)
public class ClassName {
    int method1(int x, int y) {
        int result = x + y;
        return result;
    }
    void method2() {
        int result1 = method(10, 20); // result1에 30 저장
        double result2 = method1(10, 20); //result2에 30.0 저장
    }
}
#클래스 내부에서 메소드 호출
ex)
public class Calculator {
    int plus(int x, int y) {
        int result = x + y;
        return result;
    }

    double avg(int x, int y) {
        double sum = plus(x, y); // 2. plus 메소드 호출
        double result = sum / 2;
        return result;
    }

    void execute() {
        double result = avg(7, 10); //1, avg 메소드 호출
        println("실행 결과 : "+ result); //3. println 메소드 호출
    }

    void println(String message) {
        System.out.println(message);
    }
}

public class CalculatorExample {
    public static void main(String[] args) {
        Calculator myCalc = new Calculator();
        myCalc.execute(); // Calculator의 execute() 메소드 호출
    }
}
#클래스 외부에서 메소드 호출(객체 외부)
외부 클래스에서 메소드를 호출하려면, 아래와 같이 우선 클래스로부터 객체를 생성해야 한다.
'메소드는 객체에 소속된 맴버이므로, 객체가 존재하지 않으면 메소드도 존재하지 않는다'.
ex)
클래스 참조변수 = new 클래스(매개값1, 매개값2, ...); // 객체 생성
객체가 생성되었다면, 참조 변수와 함께 도트 (.) 연산자로 메소드를 호출할 수 있다.
'도트(.) 연산자는 객체 접근 연산자로 객체의 필드, 매소드에 접근할 때 사용한다'.
ex)
참조변수.메소드(매개값1, 매개값2, ...); // 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
타입 변수 = 참조변수.메소드(매개값1, 매개값2, ...); // 리턴값이 있고, 리턴값을 저장할 경우
ex)
Car 객체의 keyTurnOn() 메소드, run() 메소드, getSpeed() 메소드를 호출하는 코드
Car myCar = new Car(); // 객체 생성
myCar.keyTurnOn(); // 리턴값x, 단순 호출
myCar.run(); // 리턴값x, 단순 호출
int speed = myCar.getSpeed(); // 리턴값을 받아 변수 speed에 저장
ex)
public class Car {
    #// 필드
    int speed;
    #// 생성자

    #// 메소드
    int getSpeed() {
        return speed;
    }

    void keyTurnOn() {
        System.out.println("키를 톨립니다.");
    }

    void run() {
        for(int i = 10, i <= 50, i += 10) { #// 시속 10씩 증가
            speed = i;
            System.out.println("달립니다. (시속 : "+ speed + "km/h");
        }
    }
}

public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car(); // 객체 생성
        myCar.keyTurnOn();
        myCar.run();
        int speed = myCar.getSpeed();
        System.out.println("현재속도 : "+ speed + "km/h");
    }
}
#유레카
'main 메소드에서 객체를 생성해야 객체.참조변수 식으로 실행을 시킬 수 있다'.
ex)
package first;

public class ObjectTest{
    
    String text = "haha";
    
    public static void main(String[] args) [

        System.out.println(text);
    ]
}
여기 ObjectTest 클래스에서 String text를 haha로 정의하고 메인 메소드에서 text를 
출력하려고 하니 같은 클래스인데도 출력이 안된다!

왜냐면 매인 메소드 안에는 text에 대한 정보가 없기 때문이다. 
text가 없는데 뭘 부르겠다는 것이냐? 이렇게 인지를 하는 거다.
즉, 클래스 안에 있다고 해서 메인 메소드에서 바로 갖다 쓰지는 못한다.

이제 클래스에서 text를 가져와서 출력을 해야겠는데 클래스명인 
'ObjecTest의 내용을 메인 메소드에서 쓸 수 있게 하는 것이 객체화!!!'
ex)
package first;

public class ObjectTest{
    
    String text = "haha";
    
    public static void main(String[] args) [

        ObjectTest ot = new ObjectTest();

        System.out.println(text);
    ]
}
가져올 클래스명 / 변수명 = new / 갖고 올 클래스명();
이런 식으로 작성을 하는데 변수명을 주는 이유는 변수명을 통해 클래스와 메인 메소드를 연결하는 것이다.
그래서 보면 '객체화를 통해 클래스와 메인 메소드를 연결하는 것이다'.

하지만 위에 로직을 실행해 봐도 에러가 뜨는 것을 볼 수 있다.
아까 뭘로 클래스와 메인 메소드를 연결했다고 했더라?
ex)
package first;

public class ObjectTest{
    
    String text = "haha";
    
    public static void main(String[] args) [

        ObjectTest ot = new ObjectTest();

        System.out.println(ot.text);
    ]
}
'객체화를 하면서 준 변수명을 통해 객체화 메인 메소드를 연결한다!!!'

ot.text를 하니까 에러 없이 출력이 잘 되는데 클래스와 메소드를 연결해서 사용하려면 객체화를 해야하고
객체화를 하면서 '준 변수명을 통해 클래스에 있는 것을 메소드에 가져다 쓴다.'
근데 여기서 객체화는 지금 쓰는 클래스인 ObjectTest 클래스만 가져올 수 있는게 아니라 다른 클래스도 가져다 쓸 수 잇다.
ex)
package first;

public class ObjectTest{
    
    String text = "haha";
    
    public static void main(String[] args) [

        ObjectTest ot = new ObjectTest();
        Bush bs = new Bush();

        System.out.println(ot.text);
        System.out.println(bs.GarenSaid);
    ]
}
클래스는 자동차 설계서, 객체화를 통해 실제 자동차 구현!
클래스 내에 있는 정보를 메인 메소드에서 바로 가져다 쓸 수가 없으니,
객체화(클래스명 변수명 = new 클래스명() )을 통해 객체와 메인 메소드를 연결해서 
지정한 변수명으로 클래스 내의 정보를 가져다 쓰고,
객체화를 통해 메인 메소드 한 곳에서 여러 클래스의 정보를 가져다 쓸수 있다.

#메소드 오버로딩
클래스 내에 같은 이름의 매소드를 여러 개 선언하는 것.
하나의 메소드 이름으로 여러 기능을 담는다. (오버로딩 : 많이 싣는 것)
메소드 오버로딩 조건: 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다. (구별조건)
ex)
class 클래스 {
    리턴타입 메소드 이름 (타입 변수, ...) {...} ---
    |               |                           |(매개변수의 타입, 개수, 순서 중 하나가 달라야함)
    |(무관)         |(동일)                      |
    리턴타입 메소드 이름 (타입 변수, ...) {...} ---
}
#메소드 오버로딩이 필요한 이유
'매개값을 다양하게 받아서 처리할 수 잇도록 하기 위함'.
ex)
int plus(int x, int y) {
    int result = x + y;
    return result;
}
만약 int 타입이 아닌, double 타입의 덧셈을 하기 위해서는 plus 메소드를 사용할 수 없다.(plus 메소드는 int 타입이기 때문에)
따라서 매개 변수가 double인 타입으로 선언된 plus() 메소드를 하나 더 선언해야한다.(메소드 오버로딩)
ex)
int plus(int x, int y) {
    int result = x + y;
    return result;
}
double plus(double x, double y) {
    double result = x + y;
    return result;
}
오버로딩된 메소드를 호출할 경우 jvm은 매개값 타입을 보고 메소드를 선택한다.
ex)
plus(10, 20); // plus(int x, int y)가 호출된다.
plus(10.0, 20.0); // plus(double x, double y)가 호출된다.
#매개 변수 타입이 섞여있다면?
int x = 10;
double y = 20.3;
plus(x, y); // x는 int, y는 double
컴파일 에러는 발생하지 않는다. plus(double x, double y)메소드가 호출된다.
가상 머신은 일차적으로 매개 변수 타입을 보지만, 매개 변수 타입이 일치하지 않는 경우,
자동 타입 변환이 가능한지 검사한다.
즉, 첫 번째 매개 변수는 int는 double 타입으로 자동 변환이 가능하기 때문에
plus(douebl x, double y)가 선택된다.

#메소드 오버로딩 Calculator.java 
public class Calculator {
    #// 정사각형의 넓이
    double areaRectangle(double width) {
        return width * width;
    }
    #// 직사각형의 넓이
    double areaRectangle(double width, double height) {
        return width * height;
    }
}

public class CalculatorExample {
    public class static main(String[] args) {
        Calculator myCalcu = new Calculator();

        #// 정사각형 넓이
        double result1 = myCalcu.areaRectangle(10);

        #// 직사각형 넓이
        double result2 = myCalcu.areaRectangle(10, 20);

        #// 결과 출력
        System.out.println("정사각형 넓이 : "+ result1);
        System.out.println("직사각형 넓이 : "+ result2);
    }
}

#인스턴스 맴버와 this
객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 의미한다.(인스턴스 필드, 인스턴스 메소드라고 불린다.)
이전에 작성한 모든 필드와 메소드는 인스턴스 멤버이다.
인스턴스 필드와 메소드는 객체에 소속된 멤버이기 떄문에 객체 없이는 사용할 수 없다.
ex)
Car 클래스에 gas 필드와 setSpeed()메소드가 아래와 같이 선언
public class Car {
    #// 필드
    int gas;
    #// 메소드
    void setSpeed(int speed) {...}
}
'gas 필드와 setSpeed() 메소드는 인스턴스 멤버이기 때문에 외부 클래스에서 사용하기 위해서는
먼저 Car 객체(인스턴스)를 생성하고 참조 변수 myCar, yourCar 로 접근해야 한다'.
Car myCar = new Car();
myCar.gas = 10;
myCar.setSpeed(60);

Car yourCar = new Car();
yourCar.gas = 20;
yourCar.setSpeed(60);

인스턴스 필드 gas는 객체마다 따로 존재하고,
인스턴스 메소드 setSpeed()는 객체마다 존재하지 않고, 메소드 영역에 저장되고 공유된다.

#this(객체 자신)
객체 외부에서 인스턴스 멤버에 접근하기 위해 참조변수를 사용하는 것처럼
객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.(객체 자신 = "this")
'this.model : 자신이 가지고 있는 model 필드 의미'
this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우,
인스턴스 멤버인 필드임을 명시랗 때 사용된다.
ex)
Car(String model) {
    this.model = model;
}
void setModel(String model) {
    this.model = model;
}
매개 변수 model 값을 필드 model에 저장한다.

public class Car {
    #// 필드 
    String model;
    int speed;

    #// 생성자
    Car(String model) {
        this.model = model; // 생성자의 매개 변수로 온 값을 필드에 저장
    }

    #// 메소드
    void setSpeed(int speed) {
        this.speed = speed;
    }

    void run() {
        for(int i = 10, i <= 50, i += 10) {
            this.setSpeed(i);
            System.out.println(this.model + "달립니다. (시속 :"+ this.speed + "km/h");
        }
    }
}
#클래스의 구성 요소 2
자바에서 클래스는 맴버로 '속성을 표현하는 필드'와 '기능을 표현하는 메소드'를 가집니다.
또한, 클래스는 생성된 객체의 필드를 초기화해주는 특별한 메소드인 생성자를 가집니다.
-예제
class Car { ; // 클래스 이름
    private String modelName; // 필드
    private int modelYear; // 필드

    Car(String modelName, int modelYear) { ; // 생성자
        this.modelName = modelName;
        this.modelYear = modelYear;
    }

    public String getModel() { ; // 메소드
        return this.modelYear + "년식" + this.modelName + "" + this.color;
    }
}

필드
클래스의 필드란 클래스에 포함된 변수를 의미를합니다.
클래스의 내에서 필드는 선언된 위치에 따라 다음과 같이 구분됩니다.
1.클래스 변수 
2.인스턴스 변수
3.지역변수 
-예제
Class Car {
    static int modelOuutput; // 클래스 변수
    String modelName; // 인스턴스 변수

    void method() {
        int something = 10; // 지역변수
    }
}
클래스 변수와 인스턴스 변수는 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화될 것입니다.
하지만 지역변수는 사용하기 전에 초기화하지 않으면, 자바 컴파일러가 오류를 발생시킵니다.

#클래스 변수와 인스턴스 변수
클래스 영역에 위치한 변수 중에서 static 키워드를 가지는 변수를 클래스 변수(static variable)라고 합니다.
그리고 클래스 영역에 위치한 변수 중 static 키워드를 가지지 않는 변수는 인스턴스 변수(instance variable)이라고 합니다.
또한, 메소드나 생성자, 초기화 블록 내에 위치한 변수를 지역변수(local variable)이라고 합니다.

변수        생성시기                    소멸시기        저장 메모리     사용 방법
클래스      클래스가 메모리에 올라갈 때/ 프로그램이 종료/ 메소드 영역   클래스 이름.변수이름
인스턴스    인스턴스가 생성될 때      /  인스턴스가 소멸/ 힙 영역       인스턴스이름.변수이름
지역        블록 내에서 변수의 선언문 실행/ 블록 벗어날 때/ 스택 영역   변수이름

클래스 변수는 인스턴스를 생성하지 않고도 바로 사용가능. ;// 전역변수 static
따라서 이러한 클래스 변수를 공유 변수라고도 불린다.

이런한 클래스 변수는 해당 클래스의 모든 인스턴스가 공유해야 하는 값을 유지하기 위해 사용합니다.
반면에 인스턴스 변수는 인스턴스마다 가져야 한는 고유한 값을 유지하기 위해 사용됩니다.
-예제
class Field {
    static int classVar = 10; // 클래스 변수 선언
    int instanceVar = 20; // 인스턴스 변수 선언
}

public class Member01 {
    public static void main(String[] args) {
        int var = 30; // 지역 변수 선언
        System.out.println(var + "\n"); // 지역 변수 참조

        Field myField1 = new Field(); // 인스턴스 생성
        Field myField2 = new Field(); // 인스턴스 생성

        System.out.println(Field.classVar); // 클래스 변수 참조
        System.out.println(myField1.classVar);
        System.out.println(myField2.classVar + "\n");

        myField1.classVar = 100; // 클래스 변수의 값을 변경

        System.out.println(Field.classVar); // 클래스 변수 참조
        System.out.println(myField1.classVar);
        System.out.println(myField2.classVar + "\n");
        
        System.out.println(Field1.instanceVar); // 인스턴스 변수 참조
        System.out.println(Field2.instanceVar) + "\n";

        myField1.instanceVar = 200; // 인스턴스 변수의 값을 변경

        System.out.println(myField1.instanceVar); // 인스턴스 변수 참조
        System.out.println(myField2.instanceVar);
        
    }
}
실행결과
30 -var
#클래스 변수는 모든 인스턴스가 같은 값을 공유
10, -Field.clasVar
10, -myField1.classVar
10  -myField2.classVar
#클래스 변수의 값을 100으로 변경
100, -Field.classVar
100, -myField1.classVar
100  -myField2.classVar
#인스턴스 변수의 값 공유
20, -Field1.instanceVar # 클래스 변수 참조
20  -Field2.instanceVar
#인스턴스 변수의 값을 20 -> 200 변경
200, -Field1.instanceVar # 인스턴스 변수 참조
20   -Field2.instanceVar

#메소드
자바에서 클래스는 맴버로 속성을 표현하는 필드와 기능을 표현하는 메소드를 가집니다.

#메소드의 사용 목적
'클래스에서 메소들르 작성하여 사용하는 이유는 중복되는 코드의 반복적인 프로그래밍을 피할 수 있기 때문이다.
또한, 모듈화로 인해 코드의 가독성도 좋아집니다.
그리고 프로그램에 문제가 발생하거나 기능의 변경이 필요할 때도 손쉽게 유지보수를 할 수 있게 됩니다'.

#메소드 정의
클래스에서 메소드를 정의하는 방법은 일반 함수를 정의하는 방법과 크게 다르지 않습니다.
-문법
접근제어자 반환타입 메소드이릅(매개변수목록) { #// 선언부
    #// 구현부
}
-예제
class Car {
    private int currentSpeed;
    private int acecelerateTime;

    ① public void acecelerate(int speed, int second) { #// 선언부
        #// 구현부
        System.out.println(second + "초간 속도를ㄹ 시속" + speed + "(으)로 가속함!!");
    }
}
위 예제의 ①번 라인에서는 acecelerate() 메소드를 정의하고 있습니다.
'이 메소드는 public 접근 제어자를 사용하여 선언되어 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있습니다'.
'반환 타입에는 어떠한 값도 반환하지 않는다는 의미를 가진 void를 명시합니다'.
그 다으믕로 메소드의 이름을 명시하고, 매개변수로 int형 변수인 speed와 second를 전달받습니다.
이렇게 전달받은 매개변수를 가지고 메소드 구현부에서 고유한 작업을 수행할 수 있는 것입니다.

#메소드 호출
자바에서 위와 같은 방법으로 정의한 메소드는 멤버 참조 연산자(.)를 사용하여 호출할 수 있습니다.
자바에서 메소드를 호출하는 방법은 다음과 같습니다.
-문법
1.객체참조변수이름.메소드이름(); // 매개변수가 없는 메소드의 호출
2.객체참조변수이름.메소드이름(인수1, 인수2...); // 매개변수가 있는 메소드의 호출

-예제 (앞서 정의한 acecelerate() 메소드를 호출하는 예제입니다.)
Car myCar = new Car(); // 객체를 생성함.
myCar.acecelerate(60, 3); // myCar 인스턴스의 accelerate() 메소드를 호출함.

-예제2
class Car {
    private int currentSpeed;
    private int acecelerateTime;

    ① public void acecelerate(int speed, int second) { #// 선언부
        #// 구현부
        System.out.println(second + "초간 속도를ㄹ 시속" + speed + "(으)로 가속함!!");
    }
}
public class Method01 {
    public static void main(String[] args) {
        Car myCar = new Car(); //객체 생성
        myCar.accelerate(60, 3); // 메소드 호출
    }
}
실행 결과
3초간 속도를 시속 60(으)로 가속함!!

그중에서 메소드란 어떠한 특정 수행하기 위한 명령문의 집합이라할 수 있습니다.
1.접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시합니다.
2.반환 타입 : 메소드를 호출하기 위한 이름을 명시합니다.
3.매개변수 목록 : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시합니다.
4.구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합입니다.

자바에서는 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없습니다.
하지만 메소드 오버로딩을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있습니다.

이러한 메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있습니다.
또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게됩니다.

#메소드의 구분
클래스의 메소드 란 어떠한 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.
클래스 내에서 메소드는 static 키워드의 여부에 따라 다음과 같이 구분됩니다.
1.클래스 메소드 (static)
2.인스턴스 메소드
-예제
class Car {
    boolean door; // 인스턴스 변수
    void openDoor() { ;// 인스턴스 메소드
        door = true;
    }
    static void toggleDoor(boolean d) { ;// 클래스 메소드
        return !d;
    }
}

#클래스 메소드와 인스턴스 메소드
위와 같이 static 키워드를 가지는 메소드를 클래스 메소드(static)라고 합니다.
또한, static 키워드를 가지지 않는 메소드는 인스턴스 메소드라고 합니다.
클래스 메소드는 클래스 변수와 마찬가지로 인스턴스를 생성하지 않고도 바로 사용할 수 있다.
따라서 클래스 메소드는 메소드 내부에서 인스턴스 변수를 사용할 수 없습니다.
그러므로 메소드 내부에서 인스턴스 변수나 인스턴스 메소드를 사용하지 않는 메소드를 클래스 메소드로 정의하는게 일반적

다음 예제는 클래스의 메소드를 종류별로 생성하고 접근하는 예제입니다.
-예제
class Method {
    int a = 10, b = 20; // 인스턴스 변수
    int add() {
        return a + b; // 인스턴스 메소드
    }
    static int add(int x,, int y) {; // 클래스 메소드
        return x + y;        
    }
}
public class Member02 {
    public static void main(String[] args) {
        System.out.println(Method.add(20, 30)); // 클래스 메소드의 호출
        Method myMethod = new Method(); // 인스턴스 생성
        System.out.println(myMethod.add()); // 인스턴스 메소드의 호출
    }
}
실행결과
50
30

#인스턴스 변수의 초기화
클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성됩니다.
하지만 일허게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태입니다.

#생성자
'자바에서 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자라는 메소드를 제공합니다'.
자바에서 생성자의 이름은 해당 클래스의 이름과 같아야 합니다.
즉, Car 클래스의 생성자의 이름은 Car가 됩니다.
이러한 생성자는 다음과 같은 특징을 가집니다.
1.생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않습니다.
2.생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있습니다.
3.객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다.
'즉, 생성자도 하나의 메소드이르모, 메소드 오러로딩이 가능하다는 의미'.

다음 예제는 Car 클래스를 선언하면서 여러 개의 생성자를 선언하는 예제입니다.
-예제
Car(String modelName) {}
Car(String modelName, int modelYear) {}
Car(String modelName, int modelYear, String color) {}
Car(String modelName, int modelYear, String color, int maxSpeed ) {}

#생성자 사용하지 않을 때
ex)
public class BankAccount {
    String accNumber;   // 계좌번호
    String ssNumber;    // 주민번호
    int balance = 0;    // 예금잔액

    public  void initAccount(String acc, String ss, int bal) {
        accNumber = acc;
        ssNumber = ss;
        balance = bal; 
    }
    public int deposit(int amount) {
        balance += amount;
        return balance;
    }
    public int withdraw(int amount) {
        balance -= amount;
        return balance;
    }
    public void check() {
        System.out.println("계좌번호" + accNumber);
        System.out.println("주민번호" + ssNumber);
        System.out.println("예금잔액" + balance + '\n');
    }
}

public class BankAccountID {
    public static void main(String[] args) {
        BankAccount kim = new BankAccount();
        kim.initAccount("12-34-56", "990990-9090990", 20000); // 초기화(처음 값을 넣어주는 의미)

        BankAccount son = new BankAccount();
        son.initAccount("23-34-45", "950728-1234567", 20000); // 초기화

        kim.deposit(20000); // 40000
        son.deposit(30000); // 50000

        kim.withdraw(10000); // 30000
        son.withdraw(20000); // 30000

        kim.check();
        son.check();
    }
}

결과값
계좌번호 : 12-34-56
주민번호 : 990909-9090990
잔   액 : 30000

계좌번호 : 23-34-45
주민번호 : 950728-1234567
잔   액 : 30000

위의 BankAccount 클래스에서 생성자 없이 초기화 하는 방법은 다음과 같다.
public void initAccount(String acc, String ss, int bal) {
    accNumber = acc;
    ssNumber = ss;
    balance = bal;
}
많은 코드 중에서 위의 사진과 같은 코드가 핵심이다.
'위의 initAccount 메소드는 인스턴스의 초기화를 위한 메소드라고 할 수 있다'.
'initAccount 메소드를 정의해야만 인스턴스 kim, son의 매개변수를 받아줌으로써 초기화할 수 있는 것이다'.
#자바에서 생성자를 사용하는 이유
initAccount는 '필드를 초기화하기 위해서' 한 번을 호출해줘야만 한다.
즉, 별도의 initAccount를 설정해줘야만 호출이 가능하다.
'생성자'라는 것을 이용하면 '메소드를 정의하지 않아도 인스턴스의 초기화를 진행할 수도 있다'.

------------------> '객체가 생성되는 시점부터 인스턴스(초기값)을 설정하기 위해 사용한다'.

#생성자를 사용해서 초기값을 설정하는 방법
생성자 사용 방법
접근제한자(public) 메소드이름(BankAccount) (매개변수(acc, ss, bal)) {
    #//실행코드
}
생성자는 이와 같은 방법으로 간단하게 사용된다.
'매개변수의 전달값이 동일한 경우에는 this 참조변수를 사용하면 된다.'
ex)
BankAccount kim = new BankAccount("12-34-56", "990990-9090990", 2000); // 생성자 초기화
#// kim.Account("12-34-56", "990990-9090990", 2000); // 메소드 초기화
BankAccount son = new BankAccount("23-34-45", "950728-1234567", 2000); // 생성자 초기화
#// son.Account("23-34-45", "950728-1234567", 2000); // 매소드 초기화

별도의 초기화시켜주는 메소드 없이 위와 같이 문장을 구성함으로써 생성자가 호출되며 값들이 전달된다.
그리고 이 전달된 값들로 인스턴스 변수가 초기화 된다.
지그맊지 자바 생성자에 대한 이해, 이유와 개념 정리를 알아보았다.

#생성자 특징
-생성자 호출이 되지 않으면 에러가 발생한다.
-일반적으로 public 접근제한자를 사용하나 상황에 따라 private등 사용

#생성자의 선언
자바에서 클래스 생성자를 선언하는 문법
-문법
1. 클래스 이름() { 
    #// 매개변수가 없는 생성자 선언
}
2. 클래스 이름(인수1, 인수2, ...) {
    #// 매개변수가 있는 생성자 선언
}
위와 같이 '생성자 중에는 매개변수를 전달받아 인스턴스 변수를 초기화하는 생성자도 선언할 수 있다'.

다음 예제는 앞서 살펴본 Car 클래스의 생성자를 선언하는 에제
-예제2
Car(String modelName, int modelYear, String color, int maxSpeed) {
    this.modelName = modelName;
    this.modelYear = modelYear;
    this.color = color;
    this.maxSpeed = maxSpeed;
    this.currentSpeed = 0;
}
#생성자의 호출
자바에서는 new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출됩니다.
-예제3
class Car {
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;

    Car(String modelName, int modelYear, String color, int maxSpeed) {
    this.modelName = modelName;
    this.modelYear = modelYear;
    this.color = color;
    this.maxSpeed = maxSpeed;
    this.currentSpeed = 0;
    }

    public String getMethod() {
        return this.modelYear + "년식" + this.modelName + "" + this.color;
    }
}
public class Method02 {
    public static void main(String[] args) {
        Car myCar = new Car("아반떼", 2016, "흰색", 200); // 생성자 호출
        System.out.println(myCar.getModel()); // 생성자에 의해 초기화 되었는지를 확인함.
    }
}
실행 결과
2016년식 아반떼 흰색

#기본 생성자
자바의 모든 클래스를 하나 이상의 생성자가 정의되어 있어야 합니다.
하지만 특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있습니다.
이것은 자바 컴파일러가 기본 생성자(default constructor)라는 것을 기본적으로 제공해 주기 때문입니다.
'기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않습니다'.
자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면, 자동으로 다음과 같은 기본 생성자를 추가
-문법 
;클래스 이름() {

;}
다음 예제는 자바 컴파일러가 Car 클래스에 자동으로 추가해 주는 기본 생성자 예제입니다.
-예제
Car() {
    #이와 같은 기본 생성자는 어떠한 매개변수도 전달받지 않으며, 기본적으로 아무런 동작도 하지 않는다.
}
-예제2
class Car {
    private String modelName = "소나타";
    private int modelYear = 2016;
    private String color = "파란색";

    public String getMethod() {
        return this.modelYear + "년식" + this.color + "" + this.modelName;
    }
}

public class Method03 [
    public static void main(String[] args) {
        Car myCar = new Car(); // 기본 생성자의 호출
        System.out.println(myCar.getModel()); // 2016년식 파란색 소나타
    }
]
실행 결과
2016년식 파란색 소나타

위의 예제에서 Car 클래스의 인스턴스인 myCar는 기본 생성자를 사용하여 생성됩니다.
하지만 기본 생성자는 아무런 동작도 하지 않으므로, 인스턴스 변수를 클르스 필드에 바로 초기화하고 있습니다.
이처럼 인스턴스 변수의 초기화는 생성자를 사용하여 수행할 수도 있지만, 클래스 필드에서 바로 수행할 수도 있습니다.
하지만 만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않습니다.
따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생
########################################################################### 03.16 17:00
#Java 초기화란?
'컴퓨터 프로그래밍에서 초기화는 데이터 객체 혹은 변수를 위해서 초기값을 지정해주는 것'
자바 초기화로 검색을 해 보면
생성자와 묶어서 많이 나오는데, 초기화는 생성자에서 변수 값을 주는게 초기화 인가?
물론 생성자에서 변수에 값 주는것도 초기화가 맞다. 생성자에서 값을 주는것만 초기화가 아니다.
-예제
public class initializationTest {
    public static void main(String[] args) {
        int a;
        System.out.println(a);
    }
}
The local variable a may not have been initialized
에러가 뜨게 된다. 변수를 초기화 하지 않아서 에러가 뜨는 것이다.
int a = 1 을 해주면 초기화가 되고 정상적으로 출력이 되는데, 여기서 초기화가 무슨 뜻인지 간단하게 알 수 있다.
자바에서 초기화란 객체를 선언하고 값을 '최초'로 할당하는 것이다.
int a = 10 이렇게 작성한 것은 선언과 동시에 초기화한 것이고, 이후에 a = 20 이렇게 주면 초기화가 아니라
값을 바꾸는 할당이 된다.
#근데 초기화를  왜 해야할까?
-예제2
public class initializationTest {
    int a; // int, String, Boolean 선언
    String b;
    Boolean c;
    
    public static void main(String[] args) {
        initializationTest it = new initializationTest(); // 객체화
        System.out.println(it.a);
        System.out.println(it.b);
        System.out.println(it.c);
    }
}
실행 결과
0 
null
null
스크린샷 보면 클래스 영역에 선언한 맴버변수 a, b, c는 선언만 하고 초기화 안해도 되는데?
'여기서 클래스 영역에 선언한 변수들은 실행 시 초기화를 하지 않아도 int 타입에 String을 넣는다거나 혹은 String 타입의 int를 넣는 
참사를 방지하기 위해 컴파일러에서 아래에 출력한 0, null, null 처럼 자동으로 값을 할당해 준다.
그러나 메소드 안에서는 자동으로 값 할당이 되지 않기 때문에 에러가 뜨는 것이다.'
마지막으로 정리해보자면, Java에서 초기화 뜻은? 
-'선언한 객체에 최초로 값을 넣어주는 것'
자바에서 초기화 하는 이유는?
-'클래스 영역에서 선언할 경우에는 컴파일러가 자동으로 값을 할당을 해주나 메소드 영역에서 선언할 경우에는 자동으로 값이 할당되지 않기 때문에 에러가 발생해서 그렇다'

#필드의 초기화
클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.
만약 다른 값으로 초기화하고 싶다면 두 가지 방법이 존재
1.필드를 선언할 때 초기값을 주는 방법
2.생성자에서 초기값을 주는 방법(매개변수)
'필드를 선언할 때 초기값을 주게 되면, 동일한 클래스로붙터 생성되는 객체들은 모두 같은 데이터를 갖게 된다'.
'객체 생성 후 변경할 수 있지만, 객체 생성 시점에는 필드 값이 모두 같다'.
ex)
korean 클래스에 nation 필드를 선언하면서 "대한민국"으로 초기값을 준 경우
korean 클래스로부터 k1, k2 객체를 생성하면, k1, k2 객체의 nation 필드는 "대한민국"이 저장되어 있다.
public class Korean {
    String nation = "대한민국";
    String name; 
    String ssn;
}
Korean k1 = new Korean(); // nation 필드에 "대한민국" 저장됨
Korean k2 = new Korean();
객체 생성 시점에서 외부에서 제공되는 다양한 값들로 초기화 되어야 한다면 생성자에서 초기화를 해야 한다.
위의 코드에서 name(이름), ssn(주민번호) 필드 값은 클래스를 작성할 때 초기값을 줄 수 없고 객체 생성 시점에 다양한 값을 가져야 한다.
'따라서 생성자의 매개값으로 이 값들을 받아 초기화 해야 한다'.
ex)
public class Korean {
    #// 필드
    String nation = "대한민국";
    String name;
    String ssn;
    #// 생성자
    public Korean(String n, String s) {
        name = n;
        ssn = s;
    }
}
name, ssn  필드는 매개변수 n, s 를 통해 값을 받는다.

ex)
public class KoreanExample {
    public static void main(String[] args) {
        Korean K1 = new Korean("Kephi", "12345-12345");

        System.out.println("K1.name : " + K1.name);
        System.out.println("K1.ssn : " + K1.ssn);

        Korean K2 = new Korean("Batzzi", "1234-1234");

        System.out.println("K2.name : " + K2.name);
        System.out.println("K2.ssn : " + K2.ssn);
    }
}
관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용한다.
하지만 이 경우, 필드와 매개 변수의 이름이 동일하기 때문에, 생성자 내부에서 해당 필드에 접근할 수 없다.
동일한 이름의 매개 변수가 사용 우선순위가 높기 때문이다.
#해결방법
필드 앞에 "this."를 붙이면 된다. 
this는 객체 자신의 참조이고, 자신을 "나"라고 하듯 객체가 객체 자신을 this라고 칭한다.
this.를 사용해서 Korean 생성자를 수정하면 아래와 같다.
public class Korean {
    #//필드
    String nation = "대한민국";
    String name;
    String ssn;

    public Korean(String name, String ssn) { #// 생성자와 매개변수가 필드와 동일한 경우 매개변수 우선
        this.name = name; // this.name (필드), name (매개변수)
        this.ssn = ssn; // this.ssn (필드), ssn (매개변수)
    }
}
객체의 필드는 하나가 아니라 여러 개가 있고, 이 필드들을 모두 생성자에서 초기화한다면
생성자의 매개 변수의 수는 필드 수만큼 선언되어야 한다.
실제로는 중요한 몇 개의 필드만 매개 변수를 통해 초기화되고, 나머지 필드들은 필드 선언시 초기화 하거나,
생성자 내부에서 임의의 값 또는 계산된 값으로 초기화한다.
또는, 객체 생성 후에 필드값을 별도로 저장하기도 한다.

#생성자 오버로딩
외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화 하려면, 생성자도 다양화될 필요가 있다.
Car 객체를 생성 시 외부에서 제공되는 데이터가 없다면, 기본 생성자로 Car 객체를 생성해야 하고,
외부에서 model, color 데이터가 제공될 경우, Car 객체를 생성할 수 있어야 한다.
(두 가지 경우일 때 모두 객체를 생성할 수 있어야 한다.)
따라서 생성자가 하나뿐이라면, 두 가지 경우에 따라 객체를 모두 생성할 수 없다.
자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공한다.
생성자 오버로딩 : 매개 변수를 달리하는 생성자를 여러 개 선언이 가능하도록 하는 것.
ex)
public class 클래스 {
    클래스 ([타입 매개변수1, 타입 매개변수2, ...]) { #// 생성자1
    }
    클래스 ([타입 매개변수1, 타입 매개변수2, ...]) { #// 생성자2

    }
}

ex) Car 클래스에서의 생성자 오버로딩
public class Car {
    Car() {}
    Car(String model) {}
    Car(String model, String color) {}
    Car(String model, String color, int maxSpeed) {}
}

#생성자 오버로딩 시 주의할 점!
매개 변수의 타입과 개수, 선언된 순서가 똑같을 경우
'매개 변수 이름만 바꾸는 것은 생성자 오버로딩으로 볼 수 없다.(구분 불가)'
Car(String model, String color) {...}
Car(String color, String model) {...} #// 오버로딩이 아니다!!!

ex) 다양한 방법으로 Car 객체가 생성된다.
Car car1 = new Car(); // 기본 생성자로 객체 생성
Car car2 = new Car("그렌저"); // Car(String model) 생성자 호출
Car car3 = new Car("그렌저", "흰색"); // Car(String model, String color) 생성자
Car car4 = new Car("그랜저", "흰색", 300); // Car(String model, String color, int maxSpeed)

ex) 생성자 오버로딩
public class Car {
    #// 필드
    String company = "현대";
    String model;
    String color;
    int maxSpeed;

    #// 생성자 오버로딩
    Car() {        
    }

    Car(String model) {
        this.model = model; // 필드 model에 매개변수 값 저장
    }

    Car(String model, String color) {
        this.model = model;
        this.color = color;
    }

    Car(String model, String, color, int maxSpeed) {
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}

ex) 객체 생성 시 생성자 선택
public class CarExample {
    public static void main(String[] args) {
        Car car1 = new Car(); // 생성자 선택1 : 기본생성자
        System.out.println("car1.company : " + car1.company); // 현대
        System.out.println();

        Car car2 = new Car("자가용"); // 생성자 선택2
        System.out.println("car2.company : "+ car2.company); // 현대
        System.out.println("car2.model : "+ car2.model); // 자가용
        System.out.println();

        Car car3 = new Car("자가용", "빨강"); // 생성자 선택3
        System.out.println("car2.company : "+ car2.company); // 현대
        System.out.println("car2.model : "+ car2.model); // 자가용
        System.out.println("car2.color : "+ car2.color); // 빨강

        Car car4 = new Car("자가용", "빨강", 200); // 생성자 선택4
        System.out.println("car2.company : "+ car2.company); // 현대
        System.out.println("car2.model : "+ car2.model); // 자가용
        System.out.println("car2.color : "+ car2.color); // 빨강
        System.out.println("car4.maxSpeed : "+ car4.maxSpeed); // 200
    }
}

#this()
생성자 오버로딩이 많아질 경우 생성자간 중복 코드가 많아질 수 있다.
매개 변수의 수만 다르게 하고 필드 초기화 내용이 비슷한 생성자에서 이런 현상이 많아진다.
이런 경우, 필드 초기화 내용은 한 생성자에서만 집중적으로 작성하고,
나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
-초기화 내용 가진 생성자
-그 초기화 내용을 가진 생성자를 호출하는 생성자
'생성자에서 다른 생성자를 호출할 때는 this() 코드를 사용한다'.
ex)
클래스( [매개변수선언, ...]) { #// 생성자 내부
    this(매개변수 값1, 매개변수 값2, ...); // 클래스의 다른 생성자 호출
}

this() 는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫 줄에서만 허용된다.
this() 의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 한다.
this() 다음에는 추가적인 실행문들이 올 수 있다.
호출되는 생성자의 실행이 끝나면, 원래 생성자로 돌아와서 다음 실행문을 진행한다.

ex)
public class ThisTest {

    int i = 10;
    int j = 20;
    
    public void TMethod(int i, int j) {
        System.out.println(i);
        System.out.println(j);
    }

    public static void main(String[] args) {
        ThisTest t1 = new ThisTest();
        t1.TMethod(1, 2);
    }
}
이번에는 This가 뭔지에 대해서 한번 알아보자 클래스 내에 변수 i, j 가 있고 각각 10, 20이다.
그리고 TMethod를 만들어 i, j 값을 각각 1과 2를 넣어 출력하게 했다.
#출력 값은 1, 2이다.

이변은 없었고 각각 1과 2가 출력이 된다. TMethod에 1과 2를 넣어 출력을 시키면,
'TMethod가 각각 int i와 int j로 인식하기 때문에 클래스 바로 뒤에 정의한 int i = 10, int j = 20과는 관련이 없어 사용되지 않는다'.
그러면 파라미터를 i와 j로 받기 때문에 이러면 클래스에 정의한 int i와 j는 사용이 불가능한가?
그건 아니고, 이럴 경우에 this를 사용한다.
ex)
public void TMethod(int i, int j) {
    System.out.println(this.i);
    System.out.println(this.j);
}

public static void main(String[] arsg) {
    ThisTest t1 = new ThisTest();
    t1.TMethod(1,2);
}
메소드 내에서 i와 j앞에 각각 this. 을 붙였다.
근데 파라미터를 i와 j로 받는 만큼 값은 별반 차이가 없다.
#출력 결과는 10, 20이다.
파라미터에 따르면 분명 1,2를 넣었기 때문에 1과 2가 출력되야 하는데 10, 20이 출력이 된다.

그렇다면 this의 의미는? 
변수명이 동일해도 this를 붙이면 파라미터에서 가져오는 변수값을 사용하는것이 아니라,
    '클래스 내에서 정의한 변수명을 사용한다는 것이다.'

즉, this를 붙임으로써 '동일한 변수명'이여도 메소드에서 가져오는 파라미터 변수명이 아닌 '클래스 내에 정의한 변수명을 사용한다'.
ex)
int i = 10;
int j = 20;

public void TMethod(int i, int j) {
    
    #this.i = i; 이 파라미터가 없으면 위의 인스턴스 값을 가져오게 될텐데, this.i, j를 작성하여 TMethod의 값을 설정하게 된다.
    #this.j = j;

    System.out.println(this.i);
    System.out.println(this.j);
}

public static void main(String[] arsg) {
    ThisTest t1 = new ThisTest();
    t1.TMethod(1, 2);
}
#출력 결과는 1, 2이다.
먼저 1, 2를 넣고 메소드를 부르면 메소드는 1,2를 가지고 안에 내용을 수행하게 된는데,
this.i 에는 1이 this.j 에는 2가 들어가게 되고 출력 시 1과 2가 출력되게 되는 것이다.

Car(String model) {
    this.model = model; // 중복되는 코드
    this.color = "은색"; // 중복되는 코드
    this.maxSpeed = 250; // 중복되는 코드
}

Car(String model, String color) {
    this.model = model; // 중복되는 코드
    this.color = color; // 중복되는 코드
    this.maxSpeed = 250; // 중복되는 코드
}

Car(String model, String color, int maxSpeed) {
    this.model = model; // 중복되는 코드
    this.color = color; // 중복되는 코드
    this.maxSpeed = maxSpeed; // 중복되는 코드
}
this()를 사용해서 앞의 두 개의 생성자에서
마지막 생성자인 Car(String model, String color, int maxSpeed)를 호출하도록 수정한다.

Car
public class Car {
    #//필드
    String company = "현대";
    String model;
    String color;
    int maxSpeed;

    #// 기본 생성자
    Car() {        
    }

    Car(String model) { #// 생성자1
        this(model, "은색", 250); // 생성자3 호출함
    }

    Car(String model, String color) { #// 생성자2
        this(model, color, 250); // 생성자3 호출
    }

    Car(String model, String color, int maxSpeed) {
        this.model = model; // 공통 실행 코드
        this.color = color;
        this.maxSpeed = maxSpeed; 
    }
}

public class CarExample {
    public static void main(String[] args) {
        Car car1 = new Car(); // 기본생성자
        System.out.println("car1.company : " + car1.company); // 현대
        System.out.println();

        Car car2 = new Car("자가용"); // 생성자 선택2
        System.out.println("car2.company : "+ car2.company); // 현대
        System.out.println("car2.model : "+ car2.model); // 자가용
        System.out.println();

        Car car3 = new Car("자가용", "빨강"); // 생성자 선택3
        System.out.println("car2.company : "+ car2.company); // 현대
        System.out.println("car2.model : "+ car2.model); // 자가용
        System.out.println("car2.color : "+ car2.color); // 빨강

        Car car4 = new Car("자가용", "검정", 200); // 생성자 선택4
        System.out.println("car2.company : "+ car2.company); // 현대
        System.out.println("car2.model : "+ car2.model); // 자가용
        System.out.println("car2.color : "+ car2.color); // 검정
        System.out.println("car4.maxSpeed : "+ car4.maxSpeed); // 200
    }
}
#필드의 초기화2
자바에서 필드는 초기화하지 않앙도 변수의 타입에 맞는 초깃값으로 자동으로 초기화됩니다.
하지만 지역변수와 마찬가지로 적절한 값으로 초기화한 후에 사용하는 것이 좋습니다.

이러한 필드는 지역 변수와는 달리 여러가지 방법으로 초기화할 수 있습니다.
자바에서는 필드를 초기화하기 위해 다음과 같은 방법들을 제공합니다.
1.명시적 초기화
2.생성자를 이용한 초기화
3.초기화 블록을 이용한 초기화

명시적 초기화는 지역 변수를 초기화하는 방법과 마찬가지로 필드를 선언과 동시에 초기화하는 방법입니다.
-예제
class Field {
    static int classVar = 10; // 클래스 변수의 명시적 초기화
    int instanceVar = 20; // 인스턴스 변수의 명시적 초기화
}
'생성자를 이용한 초기화는 객체의 생성과 동시에 필드를 초기화하는 방법입니다.'
따라서 생성자를 이용한 초기화는 인스턴스를 생성할 때까지 필드를 초기화할 수 없습니다.

#초기화 블록
필드를 초기화하는 마지막 방법으로는 자바에서 제공하는 초기화 블록을 이용하는 방법이 있습니다.
초기화 블록이란 클래스 필드의 초기화만을 담당하는 중괄호({})로 둘러싸인 블록을 의미합니다.
초기화 블록은 생산자보다 먼저 호출되며, static 키워드의 유무에 따라 다음과 같이 구분할 수 있습니다.
1.인스턴스 초기화 블록
2.클래스 초기화 블록
이러한 초기화 블록에는 다양한 명령문 및 제어문을 사용할 수 있으므로, 복잡한 초기화를 해야 할 경우 유용하게 사용됩니다.

#인스턴스 초기화 블록
인스턴스 초기화 블록은 단순히 중괄호({})만을 사용하여 정의할 수 있습니다.
이러한 인스턴스 초기화 블록은 생성자와 마찬가지로 인스턴스가 생성될 때마다 실행됩니다.
하지만 언제나 인스턴스 초기화 블록이 생성자보다 먼저 실행됩니다.
생성자와 인스턴스 초기화 블록의 차이는 거의 없으므로 인스턴스 초기화 블록은 잘 사용되지 않습니다.
단, 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드의 중복을 막을 수 있다.
다음 예제는 인스턴스 초기화 블록을 이용하여 여러 생성자에서 공통된 부분을 분리하는 예제입니다.
-예제2
class Car {
    private String modelName;
    private int modelYear;
    private String color;
    private int maxSpeed;
    private int currentSpeed;
     {
         #인스턴스 초기화 블록
         this.currentSpeed = 0;
     }

     Car() {

     }
     Car(String modelName, int modelYear, String color, int maxSpeed) {
         this.modelName = modelName;
         this.modelYear = modelYear;
         this.color = color;
         this.maxSpeed = maxSpeed;
     }

     public int getSpeed() {
         return currentSpeed;
     }
}
public class Member03 {
    public static void main(String[] args) {
        Car myCar = new Car(); // 인스턴스 생성
        System.out.println(myCar.getSpeed()); // 인스턴스 메소드의 호출
    }
}
실행결과 
0
#클래스 초기화 블록
클래스 초기화 블록은 인스턴스 초기화 블록에 static 키워드를 추가하여 정의할 수 있다.
이러한 클래스 초기화 블록은 클래스가 처음으로 메모리에 로딩될 떄 단 한 번만 실행됩니다.
클래스 초기화 블록은 생성자난 인스턴스 초기화 블록으로 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용됩니다.
-예제3
class InitBlock {
    static int classVar; // 클래스 변수
    int instanceVar; // 인스턴스 변수
    
    static { # 클래스 초기화 블록을 이용한 초기화
        classVar = 10;
    }
}
public class Member04 {
    public static void main(String[] args) {
        System.out.println(InitBlock.classVar); // 클래스 변수에 접근
    }
}
실행결과
10 

#필드의 초기화 순서
클래스의 필드는 앞서 살펴본 것과 같이 다양한 방법으로 초기화할 수 있습니다.
따라서 같은 필드가 여러 번 초기화될 가능성이 있습니다.
자바에서 필드는 다음과 같은 순서로 초기화됩니다.
1.클래스 변수 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블록
2.인스턴스 변수 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블록 -> 생성자

다음 예제는 클래스 변수와 인스턴스 변수가 초기화되는 순서를 보여주는 예제
-예제
class InitBlock {
    static int classVar = 10; // 클래스 변수의 명시적 초기화
    int instanceVar = 10; // 인스턴스 변수의 명시적 초기화
    static {
        classVar = 20; // 클래스 초기화 블록을 이용한 초기화
        instanceVar = 20; // 인스턴스 초기화 블록을 이용한 초기화
    }
    InitBlock() {
        instanceVar = 30; // 생성자를 이용한 초기화
    }
}
public class Member05 {
    public static void main(String[] args) {
        System.out.println(InitBlock.classVar);
        InitBlock myInit = new InitBlock();
        System.out.println(myInit.instanceVar);
    }
}
실행 결과
20
30
위의 예제처럼 같은 필드를 여러 번 초기화하면, 제일 마지막으로 초기화한 값만이 남게 됩니다.

#상속
상속이란 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미합니다.
이러한 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.
상속을 이용하면 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성가능.
이때 기존에 정의되어 있던 클래스를 부모 클래스(parent class) 또는 상위 클래스(super class), 기초 클래스라고도 한다.
그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스 또는 하위 클래스, 파생 클래스라고도 한다.

#상속의 장점
자바에서 클래스의 상속은 다음과 같은 장점을 가집니다.
1.기존에 작성된 클래스를 재활용할 수 있습니다.
2.자식 클래스 설계 시 중복되는 맴버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 맴버를 작성하지 않아도 됩니다.
3.클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.

#자식 클래스
자식 클래스 (child class)란 부모 클래스의 특성을 물려받아 새롭게 클래스를 의미합니다.
자바에서 자식 클래스는 다음과 같은 문법을 통해 선언합니다.
-예제
class 자식클래스 이름 extend 부모클래스 이름{}
부모 클래스에 새로운 필드를 하나 추가하면, 자식 클래스에도 자동으로 해당 필드가 추가된다.
자식 클래스에는 부모 클래스의 메소드만이 상속되며, 생성자와 초기화 블록은 상속되지 않습니다.
또한, 부모 클래스의 접근 제어가 private이나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근 불가
-예제2
class Parent {
    private int a = 10; // private 필드
    private int b = 20; // public 필드
}

class Child extends Parent {
    public int c = 30; // public 필드
    void display() {
       1 # System.out.println(a); // 상속받은 private 필드 참조
       2 System.out.println(b); // 상속받은 public 필드 참조
       3 System.out.println(c); // 자식 클래스에서 선언한 public 필드 참조
    }
}

public class Inheritance01 {
    public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
    }
}
실행 결과
20
30
위 예제의 2번 라인에서는 자식 클래스의 메소드에서 부모 클래스에서 상속받은 public 필드를 참조하고 있습니다.
이처럼 자식 클래스에서 따로 선언하지 않은 필드라도 해당 이름의 필드를 부모 클래스에서 상속받았다면 문제가 없다.
하지만 주석 처리된 1번 라인처럼 해당 필드가 부모 클래스의 private 필드라면 접근할 수 없으므로, 오류를 발생시킬 것.
또한, 자식 클래스에서는 3번 라인처럼 자신만의 필드나 메소드를 선언하여 사용할 수 있습니다.

#Object 클래스
자바에서 Object 클래스는 모든 클래스의 부모 클래스가 되는 클래스이다.
따라서 자바의 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 됩니다.
즉, 자바의 모든 클래스는 별도로 extends 키워드를 사용하여 Object 클래스의 상속을 명시하지 않아도
object클래스의 모든 맴버를 자유롭게 사용할 수 있습니다.
자바의 모든 객체에서 toString()이나 clone()과 같은 메소드를 바로 사용할 수 있는 이유가 해당 매소드들이 Object 클래스의 메소드이기 때문이다.
Object클래스에 대한 더 자세한 사항은 자바 Object 클래스 수업에서 확인할 수 있습니다.

#super 키워드
'super 키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수입니다'.
인스턴스 변수의 이름과 지역변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 사용하여 구분할 수 있었다.
이와 마찬가지로 '부모 클래스의 맴버와 자식 클래스의 맴버 이름이 같을 경우 super 키워드를 사용하여 구별할 수 있습니다.
이렇게 자바에서는 super 참조 변수를 사용하여 부모 클래스의 맴버에 접근할 수 있습니다'.
this 와 마찬가지로  super 참조 변수를 사용할 수 있는 대상도 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용 불가.
-예제
class Parent {
    int a = 10;
}

class Child extends Parent {
    void display() {
        System.out.println(a);
        System.out.println(this.a);
        System.out.println(super.a);
    }
}

public class Inheritance02 {
    public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
    }
}
실행 결과
10
10
10
위의 예제에서 int형 변수 num는 부모 클래스인 Parnet 클래스에서만 선언되어 있습니다.
따라서 지역 변수와 this 참조 변수 그리고 super 참조 변수 모두 같은 값을 출력합니다.

-예제2
class Parent {
    int a = 10;
}

class Child extends Parent {
    int a = 20;

    void display() {
        System.out.println(a);
        System.out.println(this.a);
        System.out.println(super.a);
    }
}

public class Inheritance03 {
    public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
    }
}
실행 결과
20
20
10
하지만 위의 예제에서 int 형 변수 num는 자식 클래스인 Child 클래스에서도 선언되어 있습니다.
따라서 지역 변수와 this 참조 변수는 자식 클래스에서 대입된 값을 출력하며, 
super 참조 변수만이 부모 클래스에서 대입된 값을 출력하게 됩니다.

#super() 메소드
this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면, 'super() 메소드는 부모 클래스의 생성자를 호출할 때 사용 됩니다'.
'자식 클래스의 인스턴스를 생성하면, 해당 인스턴스에는 자식 클래스의 고유 맴버뿐만 아니라 부모 클래스의 모든 맴버까지도 포함되어 있습니다'.
따라서 부모 클래스의 맴버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스 생성자까지 호출해야만 합니다.
이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 Object 클래스의 생성자까지 계속 거슬러 올라가며 수행됩니다.

따라서 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫줄에 자동으로 다음과 같은 명령문을 추가하여,
부모 클래스의 맴버를 초기화 할 수 있도록 해줍니다.

하지만 '자바 컴파일러는 컴파일 시 클레스에 생성자가 하나도 정의되어 있지 않아야만, 자동으로 기본 생성자를 추가해 줍니다.
만약 다음 예제처럼 부모 클래스에 매개변수를 가지는 생성자를 하나라도 선언했다면, 부모 클래스에는 기본 생성자가 자동으로 추가되지 않을 것입니다'.
-예제
class Parent {
    int a;
    Parent(int n){
        a = n;
    }
}
그러나 다음 예제처럼 'Parent 클래스를 상속받은 자식 클래스에서 super() 메소드를 사용하여 부모 클래스의 기본 생성자를 호출하게 되면, 오류 발생'
-예제2
class Parent {
    int a;
    Parent(int n) {
        a = n;
    }
}
class Child extends Parent {
    int b;
    Child() {
        super();
        b = 20;
    }
}
왜냐하면 '부모 클래스읜 Parent 클래스에는 기본 생성자가 추가되어 있지 않기 때문입니다'.
따라서 '매개변수를 가지는 생성자를 선언해야 할 경우에는 되도록이면 다음 예제처럼 기본 생성자까지 명시적으로 선언하는 것이 좋다'.
-예제3
class Parent {
    int a;
    Parent() {
        a = 10;
    }
    parent(int n){
        a = n; // n = 10;
    }
}
class Child extends Parent {
    int b;
    Child() {
        #//super(40);
        b = 20;
    }
    void display() {
        System.out.println(a);
        System.out.println(b);
    }
}
public class Inheritance04 {
    public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
    }
}
실행결과
10
20
위의 에제를 그냥 실행하면, 자바 컴파일러는 주석 처리된 1번 라인에 자동으로 super() 구문을 삽입할 것이다.
따라서 변수 a는 10으로 초기화 됩니다.
하지만 1버 라인의 주석 처리를 해제하고 실행하면, 부모 클래스인 Parent 클래스는 두 번째 생성자에 의해 초기화될 것입니다.
따라서 변수 a는 40으로 초기화 된다.

ex)
class Parent {
    int age = 45;
    String name = "Parent";
    public Parent() { #기본 생성자
        System.out.println("Parent Default Constructor");
    }
    public Parent(int_age, String_name){ #매개변수가 있는 생성자
        age=_age;
        name=_name;
        System.out.println("Parent Constructor");
    }
    public void showInfo(){ #메소드
        System.out.println("Name :" + name+ ", age :"+ age);
    }
}
class Child extends Parent{ #child 가 parent 상속
    public Child(int_age, String_name){
        System.out.println("Child Constructor");
    }
}
public class Main {
    public static void main(String[] arsg){
        Child a = new Child(25, "REAKWON"); chlid 객체 생성(초기화 값 넣음)
        a.showInfo();
    }
}
실행결과
Parent Default Constructor
Child Constructor
Name Parent age.45

클래스를 상속하게 되면 부모클래스의 디폴트 생성자를 우선 호출한다.
그리고 우리는 Child클래스에서 showInfo라는 메소드를 만들지 않았음에도 불구하고 main함수에서는 
사용하고 있따. Parent클래스를 상속 했기 때문에!!!

Child a = new Child(25, "REAKWON");
우리는 생성자를 통해서 age, Name을 바꾸고 싶다는 거다.

#super, this
우리는 위의 코드를 조금 변경해서 age와 name변수의 데이터를 바꿀 수 있다.바로 부모클래스의 데이터를 직접 변경
ex)
class Child extends Parent{
    public Child(int age, String name) {
        age=age;
        name=name;
        System.out.println("Child Constructor");
    }
}
우리는 이미 Parent클래스를 상속받은 상태이다. 그렇기 때문에 Parent클래스의 변수를 접근할 수도 있다.
그런데 우리는 이미 정의된 부모 클래스의 생성자를 다시 활용해보고 싶다.
'자식클래스에서 부모클래스를 super클래스라고 부른다. 그렇기 때문에 부모클래스의 변수나 메소드, 생성자에 접근할땐 super라는 키워드를 사용'
ex)
class Child extends Parent{
    public Child(int age, String name){
        super(age, name);
        System.out.println("Child Constructor");
    }
}
이런식으로 부모클래스의 생성자(super(arsg))를 호출함으로써 구현해낼 수도 있다.
super.을 눌러 어떤 변수와 메소드들이 있는지 확인해보자. 부모클래스가 허락한다면 super클래스의 변수와 메소드를 직접 사용가능하다.
ex)
class Child extends Parent{
    public Child(int age, String name) {
        age=age;
        name=name;
        System.out.println("Child Constructor");
    }
}
이제 매개변수와 클래스 맴버 변수의 이름이 같아졋다.
클래스의 멤버 변수는 변하지 않는다. "메소드가 호출할때는 매개변수나 그 안의 지역변수가 항상 우선순위를 갖는다."
클래스에서 자기 자신을 가리킬 때는 this라는 키워드를 사용한다. 그렇기 때문에 이런 코딩을 해야한다.
ex)
class Child extends Parent{
    public Child(int age, String name){
                this.age=age;
                this.name=name;
        System.out.println("Child Constructor");
    }
}
this.age는 자기 자신의 변수 age를 명시적으로 나타낸다. 어? 우리는 Child에는 age와 name이라는 변수가 없는데요?
아까 말했다시피 상속을 맏았기 때문에 슈퍼클래스의 변수도 이제 Child 클래스의 것이다. 그래서 super.age이건
this.age이건 age접근하는 것은 결론적으로 같다.
#메소드 오버라이딩
앞서 배운 오버로딩 이란 서로 다른 시그니처를 갖는 여러 메소드를 하나의 이름으로 정의하는 것이엿다.
'오버라이딩' 이란 '상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니처를 갖는 메소드로 다시 정의하는 것'.
자바에서 자식 클래스는 부모 클래스의 private 멤버를 제외한 모든 메소드를 상속받는다.
이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 '재정의'하여 사용할 수도 있습니다.
즉, 메소드 오버라이딩이란 상속받은 부모 클래스의 메소드를 재정의햐여 사용하는 것을 의미합니다.

#오버라이딩 조건
자바에서 메소드를 오버라이딩하기 위한 조건은 다음과 같습니다.
1.오버라이딩이란 메소드의 동작만을 재정의하는 것이므로, 메소드의 선언부는 기존 메소드와 완전히 같아야 합니다.
    하지만 메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환할 수 있는 타입이라면 변경할 수 있습니다.
2.부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 있습니다.
3.부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없습니다.

자바에서는 메소드 오버라이딩을 통해 상속받은 부모 클래스의 메소드를 자식 클래스에서 직접 재정의할 수 있다.

다음 예제는 부모클래스인 Parent 클래스의 display() 메소드를 자식 클래스인 Child 클래스에서 오버라이딩하는 에제입니다.
-예제
class Parent {
    void display() {
        System.out.println("부모 클래스의 display() 메소드입니다.");
    }
}
class Child extends Parent {
    void display() {
        System.out.println("자식 클래스의 display() 메소드입니다.")
    }
}
public class Inheritance05 {
    public class void main(String[] args) {
        Parent pa = new Parent();
        pa.display();
        Child ch = new Child();
        ch.display();
        Parent pc = new Child();
        pc.display(); // Child cp = new Parent();
    }
}
실행 결과
부모 클래스의 display() 메소드입니다.
자식 클래스의 display() 메소드입니다.
자식 클래스의 display() 메소드입니다.

위의 예제에서 세 번째와 같은 인스턴스의 참조가 허용되는 이유는 바로 자바에서의 다형성 때문이다.

#오버로딩 과 오버라이딩
오버로딩과 오버라이딩은 그 단어의 유사함으로 인해 혼동쉽다.
간단히 정리하자면, 오버로딩은 새로운 메소드를 정의하는 것.
오버라이딩은 상속받능 기존의 메소드를 재정의하는 것.
es)
다음 예제는 부모 클래스인 Parent 클래스의 display() 메소드를 자식 클랫인 Child 클래스에서 오버라이딩과 오버로딩을 둘 다 수행

class Parent {
    void display() { 
        System.out.println("부모 클래스의 display() 메소드입니다."); 
    }
}
class Child extends Parent {
    #// 오버라이딩된 display() 메소드
    void display() {
        System.out.println("자식 클래스의 display() 메소드입니다.");
    }
    void display(String str) {
        System.out.println(str); // 오버로딩된 display() 메소드
    }
}
public class Inheritance06 {
    public static void main(String[] args) {
        Child ch = new Child();
        ch.display();
        ch.display("오버로딩된 display() 메소드입니다.");
    }
}
실행결과
자식 클래스의 display() 메소드입니다.
오버로딩된 display() 메소드입니다.

#다형성
'다형성'이란 '하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미'.
자바에서는 이러한 다형성을 '부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록' 구현

#다형성의 본질
1.인터페이스를 구현한 객체 인스턴스를 '실행 시점에 유연하게 변경할 수 있다.'
2.다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함.
3.'클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.'

#다형성의 성립조건
1.클래스 계층구조(상속관계)
2.메소드 재정의, 동적 바인딩
3.업캐스팅 후 재정의 된 메소드 호출

#참조 변수의 다형성
자바에서는 다형성을 위해 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하고 있다.
이때 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있다.

-예제
class Parent {...}
class Child extends Parent {...}

Parent pa = new Parent(); // 허용
Child ch = new Child(); // 허용
Parent pc = new Child(); // 허용
Child cp = new Parent(); // 오류발생.

특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있습니다.
참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문입니다.
그리고 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있습니다.
참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 적기 때문이다.
하지만 반대의 경우인 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없습니다.
참조 변수가 사용할 수 있는 개수가 실제 인스턴스의 맴버 개수보다 많기 때문이다.

#참조 변수의 타입 변환
자바에서는 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있습니다.
1.서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있습니다.
2.자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있습니다.
3.하지만 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시.
'작은거에서 큰거로는 강제변환인 가능한데, 큰거에서 작은거는 데이터 손실이 발생하기 때문에 강제변환이 힘들다'.
ex)
class Parent {...}
class Child extends Parent {...}
class Brother extends Parent {...}

Parent pa01 = null;
Child ch = new Child();
Parent pa02 = new Parent();
Brother br = null;

pa01 = ch; // pa01 = (Parent)ch; 와 같으며, 타입 변환을 생략할 수 있다.
br = (Brother)pa02; // 타입 변환을 생략할 수 없음.
br = (Brother)ch; // 직접적인 상속 관계가 아니므로, 오류 발생.

ex)
class People {
    public void printInfo() {
        System.out.println("나는 사람입니다.");
    }
}

class Man extends Poeple{}
class Woman extends People{}

public class Test {
    public static void main(String[] args) {
        Man man = new Man();
        Woman woman = new Woman();

        man.printInfo();
        System.out.println();
        woman.printInfo();
    }
}
나는 사람입니다.
나는 사람입니다.

public class Test {
    publi static void main(Stringp[] args) {
        People people = new Man();

        people.printInfo();
        System.out.println();

        people = new Woman();
        people.printInfo();
    }
} 
나는 사람입니다.
나는 사람입니다.
#오버라이딩 이용
class Man extends People{
    @Override
    public void printInfo() {
        super.printInfo();
        System.out.println("그리고 나는 남자입니다.");
    }
}
class Woman extends People{
    @Override
    public void printInfo() {
        super.printInfo();
        System.out.pritnln("그리고 나는 여자입니다.")
    }
}
나는 사람입니다.
그리고 나는 남자입니다.
나는 사람입니다.
그리고 나는 여자입니다.

오버라이딩된 printInfo 를 호출한다는 것을 알 수 있다.
다형성에서 People은 자식클래스에서 재정의된 메소드를 호출할 수 있다는 것이다.
그렇다면 Woman과 Man에서 단독으로 정의한 메소드는 어떻게 될까?
Man 과 Woman 클래스에서 다음과 같이 메소드를 추가해보자.
ex)
class Man extends People{
    @Override
    public void printInfo() {
        super.printInfo();
        System.out.println("그리고 나는 남자입니다.");
    }

    public void enlist() {
        System.out.println("내일 군대를 갑니다.");
        System.out.println("충성!");
    }
}
class Woman extends People{
    @Override
    public void printInfo() {
        super.printInfo();
        System.out.println("그리고 나는 여자입니다.");
    }
     
    public void makeUp() {
                System.out.println("예뻐질 거랍니다.");
        System.out.println("톡톡 촵촵!");
    }
}
그리고 people.enlist를 호출하려한다면 호출이 되지 않는다. 왜냐 People 형이기 때문이다.
People 클래스는 enlist라는 메소드를 갖지 않기 때문에 호출할 수 없다.

이런 경우에는 데이터 형에 맞게 캐스팅해주어서 사용해야합니다.
ex)
public class Test {
    public static void main(String[] args) {
        People people = new Man();
        people.printInfo();
        ((man))people.enlist();

        System.out.println();

        people = new Woman();
        people.printInfo();
        ((Woman)people).makeUp();
    }
}
형에 맞게 캐스팅을 해주어야 하는 이유는, People은 자신을 상속한 클래스 중에서 어떤 메소드를 만들지, 어떤
멤버 녀수를 만들어낼지 미리 알아낼 수 없기 때문이다. 그래서 메소드가 있는 객체로 직접 캐스팅해주어서 메소드를 사용해야한다.
ex)
'대표적으로 메소드에서 매개변수로 People을 상속하는 클래스를 받을때 사용가능하다'.

public static void func(People people) { #func의 매개변수 people은 People의 객체이기 때문에 그것을 상속하는 모든 클래스를 받아 낼 수 있다.
    people.printInfo();
}
public static void main(String[] args) {
    Man man = new Man();
    Woman woman = new Woman();
    func(man);

    System.out.println();
    func(woman);
}
#instanceof 연산자
이러한 다형성으로 인해 런타임에 참조 변수가 실제로 참조하고 있는 인스턴스의 타입을 확인할 필요성이 생깁니다.
자바에서는 instanceof 연산자를 제공하여, 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 확인할수 있도록 해줍니다.

왼쪽에 전달된 참조 변수가 실제로 참조하고 있는 인스턴스의 타입이 오른쪽에 전달된 클래스 타입이면 true를 반환하고, 아니면 false를 반환
만약에 참조 변수가 null을 가리키고 있으면 false를 반환합니다.
ex)
class Parent {}
class Child extends Parent {}
class Brother extends Parent {}

public class Polymorphism01 {
    public static void main(String[] args) {
        Parent p = new Parent();
        System.out.println(p intanceof Object); // true
        System.out.println(p intanceof Parent); // true
        System.out.println(p intanceof Child); // false
        System.out.println(); 

        Parent c = new Child();
        System.out.println(c intanceof Object); // true
        System.out.println(c intanceof Parent); // true
        System.out.println(c intanceof Child); // true
    }
}

#추상 메소드
추상 메소드란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미.
자바에서 추상 메소드를 선언하여 '사용하는 목적은 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 
추상 메솓를 구현하도록 하기 위함'.
예를 듦ㄴ 모듈처럼 중복되는 부분이나 공통적인 부분은 미리 다 만들어진 것을 사용하고, '이를 받아 사용하는 쪽에서는 자신에게 필요한
부분만을 재정의하여 사용'함으로써 생산성이 항상되고 배포등이 쉬어지기 때문이다.
이런한 추상 메소드는 선언부만이 존재하며, 구현부는 작성되어 있지 않는다.
바로 '이 작성되어 있지 않은 구현부를 자식 클래스에서 오버라이딩하여 사용하는 것이다'.

-문법 : abstract 반환타입 메소드이름();

위와 같이 선언부만 있고 구현부가 없다는 의미로 선언부 끝에 바로 세미콜론을 추가한다.

#추상 클래스
ex)
public abstract class AbstractClass {
    
    public AbstractClass() {
        System.out.println("MAKE Abs");
    }

    public abstract void absEmptyMethod2();

    public void absMethod() {
        System.out.println("method abs");
    }

    public class void main(String[] arsg){
        #// AbstractClass ac = new AbstractClass(); abstract class는 객체화 불가
    }
} 
추상클래스의 특징은 abstract를 넣어 메소드를 정의만 할 수 있고,
동시에 일반 메소드를 정의, 구현을 할 수 있다.
'인터페이스는 정의만 할 수 있는데 추상 클래스는 정의와 구현도 가능한 것이다'.
다른 특징으로는 '추상 클래스는 객체화(인스턴스화)가 불가능하다'.
ex)
public class getAbstract extends AbstractClass {

    @Override
    public void absEmptyMethod2() {
    }

    public static void main(String[] args) {
        getAbstract ga = new getAbstract();
        ga.absMethod();
    }
}
위 예제를 보면 추상 클래스 AbstractClass를 상속받은 getAbstract 클래스인데, 
추상 클래스를 상속받을 시 추상 클래스에서 구현까지 한 메소드는 다시 구현할 필요가 없지만 
'추상 메소드는 반드시 구현하거나 클래스 형태를 추상 클래스로 바꿔줘야 한다'.

마지막으로 정리해보자면, 추상 클래스는 클래스 왼쪽에 abstract를 붙인 클래스인데, 추상 클래스에는 abstract를 
붙여 메소드를 정의만 하거나 혹은 붙이지 않고 구현까지 모두 가능하다.
'다만 추상 클래스를 상속받아 사용 시'에는 추상 클래스에 구현한 추상 메소드는 반드시 구현해주거나 혹은
상속받은 클래스를 abstract 클래스로 바꿔줘야 한다.

추상클래스의 용도는 위에 설명한 것과 같이 추상클래스 안에 정의만 한 메소드와 정의와 구현을 같이 한 메소드를 작성.
각 클래스가 '동일하게 사용해야 하는 메소드는 구현까지 한 메소드를 쓰고', 
각 클래스별로 '개별적으로 구현해야 하는 부분은 따로 구현'이 가능하다.

ex)
public abstract class AbstractClass {
	
	public AbstractClass() { #// 생성자 
		System.out.println("MAKE Abs"); 동일하게 사용해야 하는 메소드는 구현까지 한 메소드를 쓰고
	}	
	
	public abstract void absEmptyMethod2(); 개별적으로 구현해야 하는 부분은 따로 구현
	
	public void absMethod() {
		System.out.println("method abs"); 동일하게 사용해야 하는 메소드는 구현까지 한 메소드를 쓰고
	}

	public static void main(String[] args) {
		#// AbstractClass ac = new AbstractClass(); // abstract class는 객체화 불가
	}
}
 
public class getAbstract extends AbstractClass {
	
	@Override 
	public void absEmptyMethod2() { #// 생성자
	}
	
	public static void main(String[] args) {
		getAbstract ga = new getAbstract();
		ga.absMethod();
	}	
}

#추상 클래스2
자바에서는 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상 클래스라고 한다.
이러한 '추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다'.
즉, '반드시 사용되어야 하는 메소드를 추상 클래스에 추상 메소드로 선언해 놓으면, 이 클래스를 상속받는 모든 클래스에서는
이 추상 메소드를 반드시 재정의해야 한다'.

-문법
abstract class 클래스 이름 {
    abstract 반환타입 메소드 이름();
}
이러한 추상 클래스는 동작이 정의되어 있지 않은 추상 메소드를 포함하고 있으므로, 인스턴스를 생성할 수 없다.
추상 클래스는 먼저 상속을 통해 자식 클래스를 만들고, 만든 자식 클래스에서 추상 클래스의 모든 추상 메소드를 오버라이딩하고
나서야 비로소 자식 클래스의 인스턴스를 생성할 수 있게 된다.
ex)
abstract class Animal { 
    abstract void cry(); // 추상 메소드
}
class Cat extends Animal {
    void cry(){
    System.out.println("냐옹냐옹!");
    }
}
class Dog extends Animal {
    void cry(){
    System.out.println("멍멍!");
    }
}

public class Polymorphism02 {
    public static void main(String[] args) {
        #// Animal a = new Animal(); 추상 클래스는 인스턴스를 생성할 수 없음.
        Cat c = new Cat();
        dog d = new Dog();

        c.cry();
        d.cry();
    }
}
실행결과
냐용냐용!
멍멍!

위의 예제에서 추상 클래스인 Animal 클래스는 추상 메소드인 cry() 메소드를 가지고 있다.
Animal 클래스를 상속받는 자식 클래스인 Dog클래스와 Cat클래스는 
'cry() 메소드를 오버라이딩해야만 비로소 인스턴스를 생성할 수 있다'.

#추상 메소드와 사용 목적
자바에서 추상 메소드를 선언하여 '사용하는 목적은 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하기 위함'.
만약 일반 메소드로 구현한다면 사용자에 따라 해당 메소드를 구현할 수도 있고, 안 할 수도 있다.
하지만 '추상 메소드가 포함된 추상 클래스를 상속받은 모든 자식 클래스는 추상 메소드를 구현해야만 인스턴스를 생성할 수 있으므로, 반드시 구현하게 된다'.

ex)
abstract class Animal {
    public void seeFood() {
        System.out.println("내가 음식을 봤을 때");
    }
    abstract pblic void cry();
}
class Dog extends Animal{
    @Override
    public void cry() {
        System.out.println("왈! 왈!! 왈!!!");
    }
}
class Cat extends Animal {
    @Override
    public void cry() {
        System.out.println("야옹~ 야옹~~ 야옹~~~");
    }
}
public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.seeFood();
        dog.cry();

        System.out.println();

        Animal cat = new Cat();
        cat.seeFood();
        cat.cry();
    }
}
Animal을 상속받은 클래스 Dog와 Cat은 무조건 abstract의 메소드를 오버라이딩해주어야 한다.
그렇지 않으면 Animal클래스를 상속할 수 없다.

#인터페이스
자바에서 인터페이스는 class가 아닌 interface를 만들어 사용하게 된다.
ex)
public interface InterfaceExample {
    public void mainThis(); // Interface에 정의 후 implements 하면 구현 강제
    public void makeThisWithParam(String name, int age);
}

위 코드는 interface로 만든 InterExample인데, 보면 인터페이스 안에서는 
특정 메소드를 이름 혹은 이름과 파라미터만 정의하고, 안에 내용은 없는 것이 보인다.
이는 '인터페이스의 특성상 메소드 안의 내용을 구현하지 못해서 그렇다'.
인터페이스에서는 '외형만 만들고 인터페이스를 사용하는 클래스에서 안의 내용을 구현하는 것이다'.

public class ImpleInterface implements InterExample {
    pulic static main();
}

다음은 인터페이스 InterExample을 사용하는 ImpleInterface 파일인데, 
implements 인터페이스명을 통해 인터페이스를 사용할 수 있다.
보면 '인터페이스를 implements 시, 인터페이스 안에 정의된 메소드를 구현하지 않으면 에러가 뜨는 것이 보인다'.

ex)
public class ImpleInterface implements InterExample {

    @Override
    public void makeThis() {
        System.out.println("makeThis Call");
    }

    @Override
    public void makeThisWithParam(String nameValue, int ageValue) {
        System.out.println("makeThisWithparam Call with" + nameValue + " " + ageValue);
    }

    public static void main(String[] args) {
        ImpleInterface inter = new ImpleInterface();
        inter.makeThis();
        inter.makeThisWithParam("Name", 20);
    }
}
실행결과
makeThis Call
makeThisWithParam Call with Name 20

이렇게 인터페이스를 immplements받으면 인터페이스에 정의한 메소드를 반드시 구현해주어야 한다.
이제 java에서 인터페이스의 사용법과 용도가 감이 올 텐데, 먼저 사용법은 인터페이스 안에 메소드를 정의하고 이후 사용할
클래스에서 'implements 인터페이스명'으로 사용한다.

다음으로 인터페이스의 사용 이유는 
'인터페이스 안에 구현한 메소드들은 사용하는 클래스들에서 인터페이스를 implements 시 반드시 구현해야 하기 때문에'
'특정 인터페이스 implements 시 각각 다른 클래스에서도 동일한 이름의 메소드를 구현하게 만들 수 있다'.
implements 외에 extends 역시 자주 보게 되는데, extends는 다중상속이 안되고 implemente는 다중상속이 된다.

public interface InterExample {
	public void makeThis(); // Interface에 정의 후 implements 하면 구현 강제
	public void makeThisWithParam(String name, int age);
}	
 
public class ImpleInterface implements InterExample { // InterExample implements

	@Override
	public void makeThis() { // 구현하지 않을 시 에러 발생
		System.out.println("makeThis Call");
	}

	@Override
	public void makeThisWithParam(String nameValue, int ageValue) { // 받은 파라미터명은 변경해 사용 가능
		System.out.println("makeThisWithParam Call with " + nameValue + " " + ageValue);
	}

	public static void main(String[] args) {
		ImpleInterface inter = new ImpleInterface();
		inter.makeThis();
		inter.makeThisWithParam("Name", 20);
	}	
}

#인터페이스2
자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있따는 장점을 가지게 될 것이다.
하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중상속은 지원x
하지만 '다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을 통해 다중 상속을 지원하고잇다'.
인터페이스란 다른 클래스를 작성할 때 기본이 되는 '틀을 제공하면서, 다른 클래스 사이의 중가 매개 역할까지 담당하는 일종의 추상 클래스를 의미'합니다.
자바에서 추상 클래스는 추상 메소드뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있습니다.
하지만 인터페이스는 오로지 추상 메소드와 상수만을 포함할 수 있습니다.

#인터페이스의 선언
자바에서 인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 같습니다.
인터페이스를 선언할 때에는 접근 제어자와 함꼐 interface 키워드를 사용하면 된다.
'기본 클래스는 필드, 생성자, 메소드를 구성 멤버로 가지는 반면 인터페이스는 상수와 메소드(추상)만 구성 멤버로 가진다.'

-문법 
접근제어자 interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    
    public abstract 메소드이름 (매개변수목록);
}
단, 클래스와는 달리 '인터페이스의 모든 필드는 public static final이어야 하며, 모든 메소드는 punblic abstract이어야 한다'.
이 부분은 모든 인터페이스에 공통으로 적용되는 부분이므로 이 제어자는 생략할 수  있다.
이렇게 생략된 제어자는 컴파일 시 자바 컴파일러가 자동으로 추가해 준다.

#인터페이스 구현
인터페이스는 추상 클래스와 마찬가지로 자신이 직접 인스턴스를 생성할 수는 없다.
따라서 '인터페이스가 포함하고 있는 추상 메소드를 구현해 줄 클래스를 작성해야만 한다'.

-문법
class 클래스이름 implements 인터페이스 이름 {...}

만약 모든 추상 메소드를 구현하지 않는다면, abstract 키워드를 사용하여 추상 클래스로 선언해야 한다.
ex)
interface Animal {
    public abstract void cry();
}

class Cat implements Animal {
    public void cry() {
        System.out.println("냐옹 냐옹!");
    }
}

class Dog implements Animal {
    public void cry() {
        System.out.println("멍멍!");
    }
}

punblic class Polymorphism03 {
    public static void main(String[] args) {
        Cat c = new Cat();
        Dog d = new Dog();

        c.cry();
        d.cry();
    }
}

#자바에서는 상속과 구현을 동시에 가능
-문법 : 
class 클래스이름 extends 상위클래스 이름 implements 인터페이스 이름 {...}

ex)
interface Animal {
    public abstract void cry();
}
interface Pet {
    public abstract void play();
}
 
class Cat implements Animal, Pet {
    public void cry() {
        System.out.println("냐옹 냐옹!");
    }
    public void play() {
        System.out.println("쥐 잡기 놀이하자~!");
    }
} 

class Dog implements Animal, Pet {
    public void cry() {
        System.out.println("멍멍!");
    }
    public void play() {
        System.out.println("신책가자~!");
    }
} 

public class Polymorphism04 {
    public static void main(String[] args) {
        Cat c = new Cat();
        Dog d = new Dog();

        c.cry();
        c.play();
        d.cry();
        d.play();
    }
}
위의 예제에서 Cat 클래스와 Dog 클래스는 각각 Animal과 pet이라는 두 개의 인터페이스를 동시에 구현하고 있다.

#클래스를 이용한 다중 상속의 문제점
클래스를 이용하여 다중 상속을 하면 다음 예제와 같은 메소드 출처의 모호성 등의 문제가 발생
ex)
예제
class Animal { 
    public void cry() {
        System.out.println("짖기!");
    }
}

class Cat extends Animal {
    public void cry() {
        System.out.println("냐옹냐옹!");
    }
}

class Dog extends Animal {
    public void cry() {
        System.out.println("멍멍!");
    }
}

1 class MyPet extends Cat, Dog {}

public class Polymorphism {
    public static void main(String[] args) {
        MyPet p = new MyPet();
2      p.cry();
    }
}
위의 예제에서 Cat 클래스는 각각 Animal 클래스를 상속받아 cry() 메소드를 오버라이딩하고 있다.
여기까지는 문제가 없지만, 1번 라인에서 MyPet 클래스가 Cat클래스와 Dog클래스를 동시에 상속받게되면 문제가 발생한다.
2번라인에서 MyPet클래스가 Cat클래스와 Dog클래스를 동시에 상속받게되면 문제가 발생합니다.
2번라인에서 MyPet 인스턴스인 p가 cry() 메소드인지를 구분할 수 없는 모호성을 지니게 됩니다.
이와 같은 이유로 자바에서는 클래스를 이용한 다중 상속을 지원하지 않는다.

하지만 다음 예제처럼 인터페이스를 이용하여 다중 상속을 하게 되면, 위와 같은 메소드 호출의 모호성을 방지가능하다.
ex)
interface Animal {
    public abstract void cry();
}

interface Cat extends Animal {
    publc abstract void cry();
}

interface Dog extends Animal {
    publc abstract void cry();
}

class MyPet implements Cat, Dog {
    public void cry() {
        System.out.println("멍멍! 냐옹냐옹!");
    }
}

public class Polymorphism05 {
    public static void main(String[] args) {
        MyPet p = new MyPet();
        p,cry();
    }
}
위의 예제에서는 Cat 인터페이스와 Dog 인터페이스를 동시에 규현한 MyPeT클래스에서만 cry() 메소드를 정의하므로,
앞선 예제에서 발생한 메소드 호출의 모호성이 없다.

#인터페이스의 장점
1.대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능.
2.클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발 시간을 단축할 수 있다.
3.클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 독립접인 프로그래밍이 가능하다.

1.개발시간을 단축시킬 수 있다.
인터페이스를 사용하면 인터페이스를 구현하는 클래스가 작성 될 때까지 기다리지 않고 '양쪽에서 동시에 개발을 진행할 수 있따'.
2.표준화가 가능하다.
프로젝트에 사용되는 기본 틀을 인터페이스로 작성하면, 보다 일관되고 정형화된 프로그램이 개발이 가능하다.
3.'서로 관계 없는 클래스들에게 관계를 맺어 줄 수 있다'.
상속관계가 아니여도 하나의 인터페이스를 공통적으로 구현하도록 하면서 관계를 맺어줄 수 있다.
4.'독립적인 프로그래밍이 가능하다. 클래스의 선언과 구현을 분리시킬 수 있기에 실제 구현에 독립적인 프로그램을 작성하는 것이 가능하다.
즉, 다른 클래스에 영향을 미치지 않고 수정이 가능하다'.

#'즉, 인터페이스는 외부를 서로 이어주는 다리 역할을 하며, 프로젝트를 진행할 때 다른 구성원들이 각 부분을 완성할 때까지 기다리지 않고 나눠서 코드를 컴파일할 수 있다.'


#인터페이스 
인터페이스는 명세기록 불리는데요. 추상클래스의 가장 극단적인 형태라고 보면 된다.
'인터페이스는 전부가 추상메소드로 이루어져 있습니다'.
자신의 변수도 쓸수 없고 오로지 메소드의 선언만이 있어야합니다.
ex)
interface Interface {
    public void method1();
    public void method2();
}

마치 추상클래스로 표현하자면 이렇게 표현할 수도 있다.
ex)
abstract class interface {
    public abstract void method1();
    public abstract void method2();
}

인터페이스의 사용 예제는 아래와 같다.
ex)
interface Animal {
    public void cry();
    public void sleep();
}
class Dog implements Animal {
    @Override
    public void cry() {
        System.out.println("왈! 왈왈! 왈왈왈!");
    }
    @Override
    public void sleep() {
        System.out.println("자신의 집에서 잠을 잡니다.");
    }
}
class Cat implements Animal {
    @Override
    public void cry() {
        System.out.println("야옹~ 야옹~~ 야옹~~~");
    }
    @Override
    public void sleep() {
        System.out.println("집사 얼굴 위에서 잠을 잡니다.");
    }
}
public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.cry();
        dog.sleep();

        System.out.println();

        Animal cat = new Cat();
        cat.cry();
        cat.sleep();
    }
}
Dog와 Cat은 Animal 인터페이스를 implements하고 있다. 근데, 이쩨까지 봐왔던 extends가 아니다.

#추상클래스 인터페이스
'추상클래스'는 역시 클래스이다. 단독으로 객체를 생성할 수 없지 나머지는 보통의 클래스처럼 생성자, 변수, 메소드를
갖고 있을 수 있다. 그렇기 때문에 자식 클래스에서는 변수나 구현된 메소드를 물려받기 때문에 상속 받을 수 있는 것이다.
'인터페이스' 역시 직접 객체를 생성할 수 없다. 구현되어야 할 메소드만 명시해 놓고 인터페이스를 받는 클래스는 그 인터페이스에
맞는 메소드를 구현해야한다. 그렇기 때문에 implements(구현하다.)라는 키워드로 인터페이스를 전달받을 수 있다.

클래스와는 다르게 여러개의 인터페이스를 클래스가 구현할 수 있다. 클래스로 따지자면 다중상속과 비슷한 개념
자바는 다중상속을 지원하지 않지만 다중 인터페이스를 통한 상속은 지원하고잇다.

Tip)인터피이스는 '상수와 추상메소드만 멤버로 가질 수 있다'.
Tip)추상클래스와의 차이점 : '일반 메소드와 멤버변수를 가질 수 없다'.
    => 따라서 추상 클래스보다 추상화 정도가 높다!
또한, 인터페이스는 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 추상메소드를 상속을 통해 완성하는 것처럼.
인터페이스도 '추상메소드의 몸통을 만들어주는(구현부) 클래스를 작성해야 한다'.
ex)
package cipherBug.impl
interface cipherBugImpl {
    #상수선언
    public static final int MAX_VOLUME = 10;
    public int MIN_VOLUME = 0;
    #추상메소드 선언
    public void turnOn();
    public void turnOff();
}
이렇듯 상수를 선언할 때에는 public static final 타입 상수명 = 값, 으로 선언한다.

'인터페이스에 선언된 메소드는 모두 추상메소드의 특성을 갖고 있기에', public abstract를 생략해도 이 역시 상수처럼 
컴파일 과정에서 자동적으로 붙는다.
Tip) 인터페이스의 메소드는 public abstract 로 선언한다.
인터페이스의 상수는 public static final 로 선언한다.

#extends Thread, implements Runnable 차이
ex)
public class ExtendsThread extends Thread {
    public void run() {
        System.out.println("ExtendsThread Start");
    }

    public static void main(String[] args) {
        ExtendsThread et = new ExtendsThread(); // 객체화
        et.start(); // start() 시 run() 메소드 사용
    }
}

ex)
public class ImpleThread implements Runnable {
    public void run() {
        System.out.println("ImpleThread Start");
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new ImpleThread()); // Thread
        thread.start();
    }
}
위 아래 순서대로 extends Thread를 통한 스레드 구현과 implements Runnable을 통한 스레드 구현인데,
보면 extends Thread를 사용하는 경우에는 Thread를 상속받고 객체화한 뒤에 객체명.start()를 통해 사용하고,
implements Runnable을 사용하는 경우에는 'Thread 객체 안에 쓰레드를 사요하려는 객체를 넣어줘서 객체화한' 뒤 사용한다.

보면 extends Thread 쪽이 길이가 더 짧아서 나아보일 수 있는데, 'extends의 경우에는 하나밖에 상속을 받지 못하는 만큼
클래스명 extends A, B 이렇게 사용을 못한다'. 반면 implements는 implements a,b 가 가능하기 때문에,

'뭔가 상속받아야 할 게 있다면 implements Runnable을 사용하면 되고,
    딱히 상속받을게 없다면 extends Thread를 사용해주면 된다'

#인터페이스 구현
ex)
class Computer implements cipherBugImpl {
    #상속받은 추상메소드 재정의
    @Override
    public void turnOn() {
        System.out.println("컴퓨터를 켭니다.");
    }
    @Override
    public void turnOff() {
        System.out.println("컴퓨터를 끕니다.")
    }
}
이제 메인부분에서 각 클래스의 객체를 new연산자를 이용하고 생성해주고 상속받은 메소드를 호출해주면 된다.
ex)
package cipherBug.inter;
public class CipherInterfaceExamMain {
    public static void main(String[] args) {
        #각 클래스 객체 생성
        Computer computer = new Computer();
        Fan fan = new Fan();
        #상속받은 메소드를 호출
        computer.turnOn();
        fan.turnOn();
        computer.turnOff();
        fan.turnOff();
    }
}

인터페이스는 추상클래스와 달리 다중 인터페이스 구현이 가능하다.
ex)
class Computer implements cipherBugImpl, cipherBugImpl2 {
    #상속받은 추상메소드 재정의
    @Override
    public void turnOn() {
        System.out.println("컴퓨터를 켭니다.");
    }
    @Override
    public void turnOff() {
        System.out.println("컴퓨터를 끕니다.")
    }
}
이때 구현클래스(Computer)는 모든 인터페이스의 추상 메소드에 대해 실체(실행되는) 메소들를 작성해주어야 한다.
만약 하나라도 없으면 추상크래스로 선언을 해주어야한다.

'인터페이스는 기본 틀을 만들어주는(abstract method)로 구성되어있는 클래스이고, implement는 구현할 클래스를 만드는 곳인가?'

#인터페이스는 다른 인터페이스를 상속받아서 사용할 수 도 있다.
ex)
package cipherBug.impl;
interface cipherBugImpl2 {
    public void test();
}

package cipherBug.impl;
interface cipherBugImpl extends cipherBugImpl2 {
    #상수선언
    public static final int MAX_VOLUME = 10;
    public static final int MIN_VOLUME = 0;
    #추상 메소드 선언
    public void turnOn();
    public void turnOff();
}

#세탁기 인터페이스
개발자만다 클래스명, 메소드명이 다른 현상이 생기고 나중에 유지보수가 힘들어지게 된다.
이를 방지하기 위해 implements할 인터페이스를 만든다. 또한, 자바는 C언어 처럼 다중 상속을 클래스단에서
지원하지 않는다. 하지만 인터페이스를 사용하면 다중 상속이 가능핟.
ex)
#인터페이스 생성
package deu.sample;

public interface WashingMachine {
    public void startButtonPressed();
    public void pauseButtonPresses();
    public void stopButtonPressed();
    public int changeSpeed(int speed);
}

package edu.smaple;

public interface dryCouse {
    public void dry();
}

#인터페이스 사용
package edu.sample;

public class LGWashingMachine implements WashingMachine {
    @Override
    public void startButtonPressed() {
        System.out.println("세탁기가 빨래를 시작하였습니다.");
    }

    @Override
    public void stopButtonPressed() {
        System.out.println("세탁기가 빨래를 중지하였습니다.");
    }

    @Override
    public void pauseButtonPresses() {
        System.out.println("세탁기가 빨래를 일시 중지하였습니다.")
    }

    @Override
    public int changeSpeed(int speed) {
        int rtnSpeed = 0;
        swich(speed) {
            cause1:
            rtnSpeed =20;
            break;

            cause2:
            rtnSpeed =50;
            break;

            cause3:
            rtnSpeed =100;
            break;
        }
        return rtnSpeed;
    }
}
implements 를 사용하여 LGWashingMachine 클래스 선언시 인터페이스 사용을 선언한다. '인터페이스로 선언했던
메소드를 오버라이드 하여 메소드 본문에 들어갈 코드를 구현하면 된다'.

#Test
package edu.sample;

public clas TestWashingMachine {
    public static void main(String[] args) {
        LGWashingMachine WashingMachine = new LGWashingMachine();
        WashingMachine.startButtonPressed();
        System.out.println("세탁기의 속도는" + WashingMachine.changeSpeed(3));
    }
}
실행결과
세탁기가 발래를 시작하였습니다.
세탁기의 속도는 100

#인터페이스 다중상속 예제
package edu.sample;

public class LGWashingMachine implements WashingMachine, dryCouse{
    @Override
    public void startButtonPressed() {
        System.out.println("세탁기가 빨래를 시작하였습니다.");
    }

    @Override
    public void stopButtonPressed() {
        System.out.println("세탁기가 빨래를 중지하였습니다.");
    }

    @Override
    public void pauseButtonPresses() {
        System.out.println("세탁기가 빨래를 일시 중지하였습니다.")
    }

    @Override
    public int changeSpeed(int speed) {
        int rtnSpeed = 0; // 초기값 세팅
        swich(speed) {

            cause1:
            rtnSpeed =20;
            break;

            cause2:
            rtnSpeed =50;
            break;

            cause3:
            rtnSpeed =100;
            break;
        }
        return rtnSpeed;
    }
    @Override
    public void dry() {
        System.out.println("세탁기가 완료되어 건조하기 시작하였습니다.");
    }
}

#Object클래스의 toString() 메소드
toString() 메소드는 해당 인스턴스에 대한 정보를 문자열로 반환
이때 반환되는 문자열은 클래스 이름과 함께 구분자로 '@'가 사용되며, 그 뒤로 16진수 해시 코드가 추가된다.
16진수 해시 코드 값은 인스턴스의 주소를 가리키는 값으로, 인스턴스마다 모두 다르게 반환된다.
ex)
Car car01 = new Car();
Car car02 = new Car();

System.out.println(car01.toString);
System.out.println(car02.toString);
실행 결과
Car@15ab9742
Car@6d06d69c

#String클래스 charAt() 메소드
charAt() 메소드는 해당 문자열의 특정 인덱스에 해당하는 문자를 반환한다.
만약 해당 문자열의 길이보다 큰 인덱스나 음수를 전달하면, indexOutOfBoundException 오류가 발생
ex)
String str = new String("Java");
System.out.println("원본 문자열 :" + str);

for (int i = 0, i < str.length(), i++) {
    System.out.println(str.charAt(i) + "");
}
System.out.println("\n charAt() 메소드 호출 후 원본 문자열 :" + str);
실행결과
원본 문자열 : java
J a v a
charAt() 메소드 호출 후 원본 문자열 : Java

#대표적인 String 메소드
String 클래스의 메소드는 매우 다양하며, 그중에서 많이 사용되는 메소드는 다음과 같습니다.

메소드	설명
'char charAt(int index)'해당 문자열의 특정 인덱스에 해당하는 문자를 반환함.
'int compareTo(String str)'해당 문자열을 인수로 전달된 문자열과 사전 편찬 순으로 비교함.
'int compareToIgnoreCase(String str)'해당 문자열을 인수로 전달된 문자열과 대소문자를 구분하지 않고 사전 편찬 순으로 비교함.
'String concat(String str)'해당 문자열의 뒤에 인수로 전달된 문자열을 추가한 새로운 문자열을 반환함.

'int indexOf(int ch)'
'int indexOf(String str)'
해당 문자열에서 특정 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환함.

'int indexOf(int ch, int fromIndex)'
'int indexOf(String str, int fromIndex)'
해당 문자열에서 특정 문자나 문자열이 전달된 인덱스 이후에 처음으로 등장하는 위치의 인덱스를 반환함.

'int lastIndexOf(int ch)'	해당 문자열에서 특정 문자가 마지막으로 등장하는 위치의 인덱스를 반환함.
'int lastIndexOf(int ch, int fromIndex)'	해당 문자열에서 특정 문자가 전달된 인덱스 이후에 마지막으로 등장하는 위치의 인덱스를 반환함.
'String[] split(String regex)'	해당 문자열을 전달된 정규 표현식(regular expression)에 따라 나눠서 반환함.
'String substring(int beginIndex)'	해당 문자열의 전달된 인덱스부터 끝까지를 새로운 문자열로 반환함.
'String substring(int begin, int end)'	해당 문자열의 전달된 시작 인덱스부터 마지막 인덱스까지를 새로운 문자열로 반환함.
'String toLowerCase()'	해당 문자열의 모든 문자를 소문자로 변환함.
'String toUpperCase()'	해당 문자열의 모든 문자를 대문자로 변환함.
'String trim()'	해당 문자열의 맨 앞과 맨 뒤에 포함된 모든 공백 문자를 제거함.
'length()'	해당 문자열의 길이를 반환함.
'isEmpty()'	해당 문자열의 길이가 0이면 true를 반환하고, 아니면 false를 반환함.

#Math 클래스 random() 메소드
random() 메소드는 0.0이상 1.0미만의 범위에서 임의의 double형 값을 하나 생성하여 반환합니다.
이 메소드는 내부적으로 java.util 패키지의 Random 클래스를 사용한 의사 난수 발생기를 사용하여 임의의 수를 생성
다음예제는 Math 클래스의 random() 메소드를 이용하여 0부터 99까지의 난수를 생성하는 예제이다.
ex)
System.out.println((int)(Math.random()*100)); 0~99

Random ran = new Random();
System.out.println(ran.nextInt(100)); 0~99

자바에서는 Math 클래스의 random() 메소드뿐만 아니라 java.util 패키지의 포함된 Random 클래스의 
'nextInt() 메소드를 사용해도 난수를 생성할 수 있다'.

만약 특정 범위에 속하는 난수를 생성하려면, 다음과 같이 난수 생성 범위를 조절할 수 있따.
ex)
(int)(Math.random()*6); 0~6
((int)(Math.random()*6) + 1); 1~6
((int)(Math.random()*6) + 3); 3~6

#Wrapper 클래스
프로그램에 따라 기본 타입의 데이터를 객체로 취금해야 하는 경우가 있따.
'예를 들어, 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할 수는 없다'.
이때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 한다.

이렇게 '8개의 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스를 래퍼 클래스라고 한다'.

################################################################### pause 2022.03.24 17:49

#객체 지향 프로그래밍이란?
객체 지향 프로그래밍이 등장하기 전 사용되던 구조적 프로그래밍은 더 복잡한 어플리케이션에 대한 수요가 증가하면서,
구조화된 프러그래밍의 한계가 나타나기 시작했다. 
복잡한 어플리케이션을 위해서는 실제 세계처럼 더 밀접한 모델링 방식이 필요했기 때문이다.
이를 위해 나타난 방식이 객체 지향 프로그래밍(Obejct Oriented Programming)이다.
'OOP의 핵심은 객체와 클래스'라고 할 수 있다. 이들은 '실제 개체와 같은 데이터와 행동이라는 2가지 특징을 가지고 있다'.
2가지 특징
-'데이터는 객체의 속성과 상태를 나타낼 수 있따'.
-행동은 스스로 변화하고 다른 물체와 소통 할 수 있는 능력이다.

#클래스(class)와 객체(object), 인스턴스(intstance) 차이
'클래스(틀)'란 객체를 정의하고 만들어 내기 위한 설계도 혹은 틀을 말한다. 클래스 안에는 객체를 만들어내기 위해 필요한 변수와 메소드들이 존재한다.
'객체(대상 선언)'란 클래스에 선언된 모양 그대로 생성된 실체를 말하며 '클래스의 인스턴스'라고 부른다.
'인스턴스(실체)'란 클래스를 통해서 구현해야할 대상(객체)이 실제로 구현된 실체를 말한다.
예를들어 붕어빵을 만든다고 상황을 가정해보자. 여기서 클래스는 붕어빵을 만들기 위한 틀이 되고 객체는 붕어빵이다.
그리고 인스턴스는 붕어빵 틀로 찍어낸 각각의 붕어빵이다.
팥붕어빵과 슈크림붕어빵은 같은 타입의 객체이지만, 인스턴스 관점으로 보았을 때는 다르다.

#클래스와 객체
'객체는 클래스의 인스턴스 이다'.
'각각의 객체는 상태(Feild), 행동(Method) 그리고 식별자를 갖고 있다'.
또한, 객체들은 서로간의 호출을 통해 통신할 수 있으며 이를 message passing이라고 한다.
하나의 클래스를 통해 필요로 하는 어플리케이션에 여러개의 객체를 생성할 수 있다.
각 객체의 식별은 일반적으로 JVM에 의해 유지되며 JAVA 객체를 만들 때마다 JVM은 '객체에 대한 해시코드를 만들고 할당하게 된다'.
이를 통해 JVM은 모든 객체가 고유하게 식별되도록 하낟.

#생성자
'생성자'는 '반환 값이 없는 특수한 메서드'이다. 생성자의 이름은 '항상 클래스의 이름과 동일'하며 초기 객체 상태를 설정하기 위한 매개 변수를 사용
'생성자를 작성하지 않는 경우 JVM은 기본 생성자를 할당하며 이는 매개변수를 허용하지 않기 때문에 매개변수가 필요한 경우에는 개발자가 직접 생성자를 작성'.
-> 기본 생성자는 매개변수를 허용하지 않는다. 매개변수를 사용하려면 개발자가 직접 생성자를 작성해야한다.
#OOP의 4가지 원칙
추상화(abstract)
추상화는 컨텍스트와 관련이 없는 정보를 숨기거나 관련된 정보만 알 수 있도록 하는 것.
일반적인 추상화는 데이터 추상화 와 제어 추상화로 볼 수 있다. 

#데이터 추상화
데이터 추상화는 '복잡한 데이터 형태를 생성하기 위해 여러 작은 데이터 타입을 사용'.
ex)
public class Employee {
    private Department Department;
    private Address address;
    private Education Education;
}

#제어 추상화
제어 추상화는 어떤 클래스의 메소드를 사용하는 사용자에게 해당 메소드의 작동방식과 같은 로직을 숨기기 위함이다.
만일 메소드 내 로직이 변경되더라도 실제 사용자는 변경된 내용이 어떤것인지 알 필요 없이 이전과 동일하게 메소드를 사용할 수 있다.
따라서 로직이 변경되더라도 사용자에게 영향을 주지 않는다.
ex)
public class EmployeeManager {
    public Address getPrefferedAddress(Employee e) {       
    }
}

#캡슐화(Encapsulation)
캡슐화는 관련이 있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 못하도록 은닉하는 것이다.
'객체의 직접적인 접근을 막고 외부에서 내부의 정보에 직접접근하거나 변경할 수 없고 객체가 제공하는 필드와 메소드를 통해서만
접근이 가능하다'. 캠슐화에는 정보은닉과 구현은닉을 모두 갖고 있다.

정보은닉의 방법으로는 '접근제어자'를 사용하여 외부에서 접근할 수 없도록 하며 '인터페이스를 통해 구현은닉'을 달성하는 것이다.
구현은닉은 객체가 책임을 이행하는 방식을 수정할 수 있도록 개발자에게 자유를 제공한다.
이는 설계가 변경 될 때 유용하게 작용할 수 있다.

이렇게 접근을 제한함으로써 유지보수나 확장 시 오류의 범위를 최소화할 수 있고, 객체 내의 정보 손상과 오용을 방지하고 데이터가 
변경되어도 다른 객체에 영향을 주지 않아 독립성이 좋다.

#접근제어자
public : 접근 제한 없음
protected : 동일한 패키지 내에 존재하거나 파생 클래스에서만 접근 가능
default : 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패캐지 내에서만 접근 가능
private : 자기 자신의 클래스 내에서만 접근 가능.
#정보 은닉
class InformationHiding {
    
    #Restrict direct access to inward data
    private ArrayList items  = new ArrayList();

    #Provide a way to access data - internal logic can safety be changed in future
    public ArrayList getItems() {
        return items;
    }
}
#implementaion hiding
interface implementaionHiding {
    Integer sumAllItems(ArrayList items);
}
class InformationHiding immplements implementaionHiding {
    #Restrict direct access to inward data
    private ArryaLitst items = new ArrayList();

    #Provide a way to access data - internal logic can safety be changed in future
    public ArrayList getItems() {
        return item;
    }

    public Integer sumAllItems(ArrayList item) {
    }
}

ex)
package com.encapsulationExample;

public class EncapsulationClass {
    private int Id;
    private String name;

    public int get Id() {        
        return Id;
    }

    public void setId(int Id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

package com.encapsulationExample;
public class Main {
    public static void main(String[] args) {
        #write your code here
        EncapsulationClass cap = new EncapsulationClass();

        cap.setId(123);
        cap.setName("Jay");

        System.out.println(cap.getId());
        System.out.println(cap.getName()  );
    }
}
출력 결과
123
Jay
위의 예제를 보면 private 접근제어자를 통해 변수를 선언해주었기 때문에 외부에서 접근할 수 없다.
그래서 getter/setter 메소드를 통해 변수에 값을 저장해주고 가져올 수 있게 해준다.

#상속(Inheritance)
자바에서의 상속은 하나의 클래스가 '부모클래스의 속성과 행동을 얻게 되는 방법이다'.
상속은 코드의 재사용성과 유지보수르 위해 사용됩니다. 상속을 사용하기 위해서는 extends 키워드를 상속 받을 클래스에 명시,
상속되는 클래스는 super클래스라고 부르고 새롭게 생성된 클래스를 sub클래스라고 한다.

sub클래스(자식)는 super클래스(부모)의 non-private 멤버들을 상속 받게되며 생성은 멤버가 아니기 때문에 상속되지 않습니다.
하지만 sub클래스에서 super클래스의 생성자를 호출할 수 있다.

#다형성(polymorphism)
다형성은 '같은 자료형에 여러가지 객체를 대입하여 다양한 결과를 얻어내는 성질을 의미'.
이를 통해 동일한 이름을 같은 여러 형태의 메소드를 만들 수 있다.(오버로딩), 자바에서는 다혀엉을 다루는 근본적인 방법이 2가지 있다.
compile time polymorphism 과 runtime polymorphism 이다.

'compile time polymorphism'은 컴파일러가 필요한 모든 정보를 가지고 있고, 프로그램 컴파일 중에 호출할 방법을 알기 때문에 컴파일 시간에 적절한
메소드를 각각의 객체에 바인딩할 수 있다. 정적바인딩이나 early binding 이라고 부른다. 자바에서는 메소드 오버로딩을 통해 사용된다.
메소드 오버로딩을 통해 메소드의 매게변수의 형태가 달라질 수 있다.

'runtime polymorphism'은 동적 바인딩이라고 불리며 메소드 오버라이딩과 연관이있다. 일반적으로 런타임 다형성은 부모 클래스와 자식 클래스가 존재할때
사용되는데 '부모자식 클래스에 존재하는 메소드를 실행시키게 되면 런타임과정에서 해당 인스턴스에 맞는 메소드를 호출하게 된다'.
ex)
class Animal {
    public void sound() {
        System.out.println("Some sound");
    }
}

class Lion extends Animal {
    public void sound() {
        System.out.println("Roar");
    }    
}

class Main {
    public static void main(String[] args) {
        #Parent class reference is pointing to a parent object
        Animal animal = new Animal();
        animal.sound(); 

        #Parent class reference is pointing to a child object
        Animal animal = new Animal();
        animal.sound();
    }
}

ex)
#다형성 예제 : 큰 개념 Human
public class Humna {
    public void call() {
        System.out.println("Human Call");
    }
}

#다형성 예제 : 작은 개념 Minsu
public class Minsu extends Human {
    public void call() {
        System.out.println("Minsu Call"); super method
    }

    public void status() {
        System.out.println("Minsu Status"); sub method
    }
}

#다형성 예제 : 큰 개념 Champion
public Interface Champion {
    public void call();
}

#다형성 예제 : 작은 개념 Garen
public class Garen implements Champion {
    @Override
    public void call() {
        System.out.println("Garen Call"); 메소드 재정의
    }
}

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

#다형성 사용 예제
public class Polymorphism {
    public static void main(String[] arsg) {
        #다형성 예제
        Human h = new Human(); # Human 객체에 Minsu 객체를 넣음
        #Minsu m = new Minsu();
        #작은 개념의 객체에 큰 개념의 객체를 넣을 수는 없음..(다운케스팅?)
        m.call(); # MInsu Call이 나오게 됨
        #m.call(); #Human에 존재하지 않는 메소드는 사용 불가

        Champion c = new Garen(); # Champion 객체에 Garen 객체를 넣음
        c.call(); #Garen Call이 나오게 됨

        Map<String, String> m = new HashMap<String, String>(); // 실 사용 예제
		Map<String, String> m2 = new LinkedHashMap<String, String>(); // 실 사
    }
}

#OOP 모범 사례
1.인터페이스 사용하여 구현하기
인터페이스를 사용하게 되면 코드의 유연성이 증가한다. 인터페이는 super class와 같은 역할을 하기 때문에 
인터페이스를 통해 레거시 코드를 변경하지 않고 메소드의 로직을 새롭게 생성 할 수 있다.

2.코드 반복하지 않기
중복되는 코드를 사용하지 않고 추상화나 추상메소드를 사용하여 해결한다.
2곳 이상에서 '동일한 코드가 작성된다면 함수로 분리하여 호출하는 방식으로 사용할 것'.

3.변경 사항 캡슐화
향후 변경 가능성이 있는 코드를 캡슐화하여 '사용자가 코드를 직접 변경하는 일을 줄일 수 있다'.
접근제어자를 사용하여 캡슐화를 진행하고 캡슐화를 달성하기 위해서는 디자인 패턴중 펙토리 디자인 페턴을 사용할 수 잇다.

4.SRP(Single Responsibility Principle)
SRP는 OOP의 solid 원칙중 하나이다. SRP는 '하나의 클래스가 단 하나의 목적'으로 클래스를 사용해야만 한다.

5.OCP(Open Closed Principle)
OCP 또한 solid 원칙 중 하나이며 확장에는 열려있고 변경에는 닫혀있어야 한다는 의미이다.
즉 '기존 코드를 변경하지 않으면서 새로운 기능을 추가하는 것에는 유연해야 한다'.

#ajax
Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자
자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능
'브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법'

즉, 쉽게 말하자면 자바스크립트를 통해서 서버에 데이터를 비동기 방식으로 요청하는것이다.

#비동기 방식이란?
비동기 방식은 웹페이지를 리로드하지 않고 데이터를 불러오는 방식이며 Ajax를 통해서 서버에 요청을 한 후 멈추어 있는 것이 아니라
그 프로그램은 계속 돌아간다는 의미를 내포하고 있다.

#비동기 방식의 장점
페이지 리로드의 경우 전체 리소스를 다시 불러와야하는데 이미지, 스크립트, 기타 코드등을 모두 재요청할 경우
불필요한 리소스 낭비가 발생하게 되지만 '비동기 방식을 이용할 경우 필요한 부분만 불러와 사용할 수 있으므로 매우 큰 장점'

#AJAX로 할 수 있는 것
네트워크 기술을 이용하여 클라이언트에서 서버로 데이터를 요청하고 그에 대한 결과를 돌려받을 수 있다.

#클라이언트 란?
서버에서 정보를 가져와서 사용자에게 보여줄 수 있고 사용자와 상호작용할 수 있는 소프트웨어를 일컫는다.
EX) 웹브라우저, 핸드폰 어클리케이션 등....

#서버 란?
네트웨크 상에서 접근할 수 있는 프로그램으로서 어떤 자료들에 대한 관리나 접근을 제어해주는 프로그램.
서버는 일반적으로 사용자가 직접적으로 사용하지 않는다.

#AJAX를 사용하는 이유
단순하게 WEB화면에서 무언가 부르거나 데이터를 조회하고 싶을 경우, '페이지 전체를 새로고침하지 않기 위해 사용한다고 볼 수 있다.'
기본적으로 HTTP 프로토콜은 클라이언트쪽에서 Request를 보내고 서버쪽에서 Response를 받으면 이어졌던 연결이 끊기게 되어있다.
그래서 화면의 내용을 갱신하기 위해서는 다시 request를 하고 response를 하며 페이지 전체를 갱신하게 된다.
하지만 이렇게 할 경우, 엄청난 자원낭비와 시간낭비를 초래하고 말 것이다.

ajax는 HTML 페이지 전채가 아닌 일부분만 갱신할 수 있도록 XMLHttpRequest객체를 통해 서버에 request한다.
이 경우, JSON이나 XML형태로 필요한 데이터만 받아 갱신하기 때문에 그만큼의 자원과 시간을 아낄 수 있다.

#AJAX의 장점
-웹페이지의 속도향상
-서버의 처리가 완료될 때까지 기다리지 않고 처리가 가능하다.
-서버에서 Data만 전송하면 되므로 전체적인 코딩의 양이 줄어든다.
-기존 웹에서는 불가능했던 다양한 UI를 가능하게 해준다.(Flickr의 경우, 사진의 제목이나 태그를 페이지의 리로드 없이 수정할 수 있다.)

#AJAX의 단점
-히스토리 관리가 되지 않는다.
-페이지 이동없는 통신으로 인한 보안상의 문제가 있다.
-연속으로 데이터를 요청하면 서버 부하가 증가할 수 있다.
-XMLHttpRequest를 통해 통신하는 경우, 사용자에게 아무런 진행 정보가 주어지지 않는다.
    (요청이 완료되지 않았는데 사용자가 페이지를 떠나거나 오작동할 우려가 발생하게 된다.)
-AJAX를 쓸 수 없는 브라우저에 대한 문제가 이슈가 있다.
-HTTP 클라이언트의 기능이 한정되어 있다.
-지원하는 Charset이 한정되어 잇다.
-Script로 작성되므로 디버깅이 용이하지 않다.
-동일-출처 정책으로 인하여 다른 도메인과는 통신이 불가능하다.

#AJAX의 진행과정
1.XMLHttpRequest Object를 만든다.
    -request를 보낼 준비를 브라우저에게 시키는 과정
    -이것을 위해서 필요한 method를 갖춘 object가 필요함
2.callback 함수를 만든다.
    -서버에서 response가 왔을 때 실행시키는 함수
    -HTML 페이지를 업데이트 함.
3.Open a request
    -서버에서 response가 왔을 때 실행시키는 함수
    -HTML 페이지를 업데이트 함.

#Session 이란
-'일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고
 그 상태를 일정하게 유지시키는 기술'이라고 한다. 또한 여기서 일정 시간이란 방문자가 웹 브라우저를 통해 웹 서버에 
 접속한 시점으로부터 웹 브라우저를 종료함으로써 연결을 끝내는 시점을 말하며 즉, 방문자가 웹서버에 접속해 있는 
 상태를 하나의 단위로 보고 세션이라고 칭한다는 것.

#Session 과 cookie 의 차이점
-쿠키를 간단하게 설명하자면 '특정 웹 사이트를 방문 했을 때 만들어지는 정보를 담는 일을 지칭'하는것이 쿠키   

-'쿠키'의 경우는 방문자의 정보를 '방문자 컴퓨터의 메모리에 저장'하는 것을 말한다.
    ex) ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는데에 사용한다.
        (IE 인터넷 옵션에서 검색 기록 삭제할때 임시 파일, 열어본 페이지 목록, 쿠키, 저장된 암호 및 웹 양식 정보 삭제라고 되어있지 아니한가)

-'세션'은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 '서버에 저장'을 하는것

그래서 쿠키와 달리 '세션은 사용자들의 로그인 정보에 대한 보안을 한층 업그레이드 할 수 있어 웹사이트에 방문하여 계속 접속을 유지할 때 이전의
정보를 이용할 수 있는 방법으로 많이들 사용하는 것이다'.

#HttpSession 이란?
1)session이란 서버가 해당 서버(웹)로 접근(request)한 클라이언트(사용자)를 식별하는 바법.
2)서버(웹)는 접근한 클라이언트(사용자)에게 response-header field인 set-cookie 값으로 클라이언트 식별자인 session-id(임이의 긴 문자열)를 발행(응답)한다.
3)서버로부터 발행(응답)된 session-id는 해당 서버(웹)와 클라이언트(브라우저) 메모리에 저장된다. 이때 클라이언트 메모리에 사용되는 cookie 타입은
    세션 종료 시 같이 소멸되는 "Memory cookie"가 사용된다.
4)서버로부터 발행된 session(데이터)을 통해 개인화(사용자)를 위한 데이터(userInfo 등)로 활용할 수 있다.

#HttpSession 동작 순서
1)클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.
2)서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.
3)만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로
    sessioin-id(임이의 긴 문자열)을 발행(응답)한다.

역시나 여러번 읽어봐도 모르겠고
전에 포스팅한곳에도 써놨지만 대략
방문자가 서버에 접속 시도 후 서버 접근한 클라이언트(방문자)가 seesion id를 보내왔는지 확인 했는데 없다면 서버는 session id를 생성하는 부분을
우리가 많이들 쓰고 있는 session_start()함수인듯 하다.

다른 블로그에서 세션을 등록하기 위해서는 가장먼저 세션을 초기화 하여 세션을 생성하고, 현재의 세션 아이디를 활성화시키기 위해 session_start 함수를 사용한다 했으니...
또한 세션을 등록할때  $_SESSION['변수명'] 이렇게 쓰며
위에 설명중 세션 종료시 같이 소멸된다라고 써있는데 물론 브라우저를 끄며서 종료된다는 개념이지만 우리는
unset($_SESSION['변수명']); 와 session_destory(); 이라는 걸 알고 있지요
(혹시나 하여 간단한 설명을 하자면 좌측은 세션 소멸과 우측은 세션 종료때 사용한다)

#리눅스
IT관련 업무를 하다 보면 리눅스라는 단어를 많이 들게 된다. 비개발자, 비전공자들은 리눅스라는 단어가 낯설것이다.

#정의
리눅스(Linux)는 리누스 토르발스가 커뮤니티 주체로 개발한 컴퓨터 운영 체제이다. 혹은 커널을 뜻하기도 한다. 리눅스라는
자유 소프트웨어와 오픈소스 개발의 가장 유명한 표본으로 들 수 있다. 리눅스는 다중 사용자, 다중작업(멀티테스킹), 다중 스레드를
지원하는 네트워크 운영 체제(NOS)이다.

여기서 핵심은 '운영체제'라는 것이다. 우리가 사용하는 윈도우즈가 운영체제이다. 컴퓨터를 켜면 윈도우즈라는 운영체제가 우리를 반겨준다.
우리한테 프로그램도 설치하게 해주고, 마우스로 클릭도 하게 해주고, 키보드로 글씨도 입력하게 해주는 운영체제라고 생각하면 된다.
자유 소프프트우ㅞ어라는 말은 Free를 해석한 결과인 듯 하다. Free는 무료의 개념도 있지만, 사용자가 소프트웨어를 자유롭게 이용(열람, 수정, 배포)
할 수 있는 권리와 라이센스를 의미하기도 한다. 무료인 덕분에 더욱 빠르게 전세계로 확장할 수 있었다.

#실무에서는
현실에서 우리가 리눅스라는 단어를 듣는다면 웹 등의 인터넷 서비스를 운영할 때이다. 우리는 서비스를 제공하기 위해 데이터를 저장하거나,
웹페이지를 제공하는 컴퓨터를 마련하게 된다. 홈페이지가 우리에게 보이는 건 어떤 컴퓨터에 '웹페이지 주세요!'하고 요청하면
그 컴퓨터들을 서버라고 부른다. IT업계에 있다면 서버라는 단어는 수천 번 들어봤을 것이다. 그 서버라는 컴퓨터는 우리가 쓰는 노트북이나
테스크톱과 같다. 가격도, 생긴 것도 좀 다르긴 하지만 컴퓨터라는 것은 매한가지이다. 그러면 그 서버라고 불리는 컴퓨터들의 운영체제는 뭘까.
컴퓨터를 켜면 누가 반겨줄까. 바로 리눅스라고 하는 운영체제이다. 

전 세계의 서버들은 다양한 운영체제들로 운영이된다. 유닉스, 리눅스 등이다. 우리에게 익숙한 윈도우즈도 윈도우즈 서버라는 서버용 제품군이 있다.
운영체제는 벽돌인 컴퓨터가 기계 장치에 생명을 불어넣는 역할을 한다. 우리도 윈도우즈가 제공하는 사용성 안에서 엑셀도 사용하고, 포토샵도 사용하니까
그럼 리눅스 안에서는 어떤 걸 사용할까. 웹서버,데이터베이스 프로그램들을 사용한다. 홈페이지를 응답해주고, 데이터를 저장해주는 프로그램을 사용한다.

리눅스가 널리 사용되는 이유 중 하나는, 무료이기 때문이다. 물론 리눅스라는 운영체제 자체도 참 좋지만, 무료라는 이유는 절대적이다.
유닉스, 윈도우즈 서버등의 운영체제는 수백, 수천 만원 단위의 운영체제이다. 돈 없는 기업들은 부담스럽다. 
웹, 앱, 데이터 등의 서비스는 굉장히 여러 대의 컴퓨터가 필요한 영역이다. 그럴 때마다 운영체제를 구매해서 사용하는 건 돈 없는 초창기 기업들에게는 쉽지 않다.

서버에서 사용하는 운영체제는 대부분 CLI 환경으로 사용한다. CLI는 Command Line Interface이다.

#EC2
-아마존 일래스틱 컴픂트 클라우드 (Amazon Elastic Compute Cloud, EC2)는 아마존닷컴의 클라우드 컴퓨링 플랫폼 아마존 웹 서비스의
 중앙부를 이루며, 사용자가 가상 컴퓨터를 임대 받아 그 위에 자신마의 컴퓨터 애플리케이션들을 실행할 수 있게 한다.
-EC2는 사용자가 아마존 머시니 이미지(AMI)로 부팅하여 아마존이 '인스턴스'라 부르는 가상 머신을, 원하는 소프트웨어를 포함하여
 구성할 수 있게 하는 웹 서비스를 제공함으로써 스케일링이 가능한 애플리케이션 배치를 장려한다.
-사용자는 필요하면 서버 인스턴스를 만들고 시작하고 종료할 수 있으며, 실행 중인 서버에 대해 시간 당 지불하므로
 '일래스틱(elastic, 탈력적인)'이라는 용어를 사용하게 된다.

#RDS
-아마존 관계형 데이터베이스 서비스 (Amazon Relational Database Service) 또는 아마존 RDS는 아마존 웹 서비스가 서비스하는 분산 관계형 데이터베이스이다.
-애플리케이션 내에서 관계형 데이터베이스의 설정, 운영, 스케일링을 단순케 하도록 설계된 클라우드 내에서 동작하는 웹 서비스이다.
-'데이터베이스 소프트웨어를 패치하거나 데이터베이스를 백업하거나 시점 복구를 활성화하는 것과 같은 복잡한 관리 프로세스들은 자동으로 관리된다'.
-스토리지와 연산 자원들을 스케일링하는 것은 하나의 API 호출로 수행할 수 있다.
 
#생각해 볼 부분
1.EC2 에 DB를 직접 설치하여 서비스하는 것과 RDS를 이용해 서비스 하는 것의 차이는?
-EC2는 내가 직접 리눅스 위에 사용하려는 DB(oracle, maria db 등)를 설치하고 그 위에 서비스하는 것이고
 RDS는 EC2와 함께 사용하며 아마존에서 DB의 설정, 운영, 백업 등의 기능을 편하게 이용할 수 있게 해주는 EC2와 분리된 DB전용서버이다.
 즉, RDS를 사용하면 내야하는 돈이 많아지므로, 테스트/개발을 하는 개발자라면... RDS는 이런거구나.. 하고 알아두고!!
 EC2에 직접 설치하고 사용하는게 좋을것 같다. 물론 이렇게 직접설치하고 설정/백업등을 한다면 공부도 더 되고 좋다.

